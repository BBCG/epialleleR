[{"path":"/articles/epialleleR.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"The epialleleR User's Guide <img style=","text":"Cytosine DNA methylation important epigenetic mechanism regulation gene expression. Abnormal methylation linked several diseases, example common molecular lesion cancer cell.1 Multiple studies suggest alterations DNA methylation, despite occurring low mosaic level, may confer increased risk cancer later life.2 cytosine methylation levels within relatively small regions human genome thought often concordant, resulting limited number distinct methylation patterns short sequencing reads.3 Due cell--cell variations methylation, DNA purified tissue samples contains mix hyper- hypomethylated alleles varying ratios depend genomic region tissue type. Unsurprisingly, frequencies hypermethylated epialleles low (e.g. 1e-02 lower) cytosine methylation levels averaged reported using conventional algorithms, identification hypermethylated epialleles becomes nearly impossible. order increase sensitivity DNA methylation analysis developed epialleleR — R package calling hypermethylated variant epiallele frequencies (VEF). Two edge cases epialleleR designed distinguish presented (examples can found ). simplified entirely artificial, still give idea two different methylation patterns may exist real life, characterised similar quantitative metrics (beta value, ratio methylated cytosines, CC, total number cytosines, C+TC+T, per genomic position, .e. β=CC+T\\beta = \\frac{C}{C+T}), entirely different biological properties: non-functional scattered methylation / technical artefacts left, epigenetic gene inactivation right. VEF values, essentially ratio methylated cytosines hypermethylated (threshold) reads, CaC^, total number cytosines, C+TC+T, per genomic position, .e. VEF=CaC+TVEF = \\frac{C^}{C+T}, clearly separate cases thought useful detection quantification concordant methylation events.  epialleleR fast scalable solution analysis data obtained next-generation methylation/native sequencing DNA samples. minimum requirement input Binary Alignment Map (BAM) file containing sequencing reads. reads can obtained either deep ultra-deep sequencing, using either narrowly targeted gene panels (amplicon sequencing), larger methylation capture panels, even whole-genome approaches.","code":""},{"path":"/articles/epialleleR.html","id":"current-features","dir":"Articles","previous_headings":"Introduction","what":"Current Features","title":"The epialleleR User's Guide <img style=","text":"methylation calls present BAM file, epialleleR can make store calls output BAM (similar Bismark Illumina’s mapping/alignment solutions; short-read sequencing alignments ) epialleleR can create store sample BAM files testing purposes means simulateBam method addition conventional reporting cytosine DNA methylation levels (beta values), epialleleR can call variant epiallele frequencies (VEF) hypermethylated alleles level individual cytosines (generateCytosineReport) supplied genomic regions (generateBedReport) Linearised Methylated Haplotype Load (lMHL, generateMhlReport) can used instead VEF thresholding recommended (long-read sequencing) DNA methylation patterns genomic region interest can explored using extractPatterns plotPatterns association methylation single-nucleotide variations within epialleles can tested using generateVcfReport Potential bimodality methylation genomic regions interest can assessed using generateBedEcdf method","code":""},{"path":"/articles/epialleleR.html","id":"processing-speed","dir":"Articles","previous_headings":"Introduction","what":"Processing speed","title":"The epialleleR User's Guide <img style=","text":"Currently epialleleR runs single-thread mode . Reading/writing BAM FASTA data now done means HTSlib, therefore possible speed significantly using additional decompression threads (nthreads option epialleleR methods). operations performed using optimised C++ functions, usually take reasonable time. methylation calling, human genome (hg38) loading usually takes 10-15 seconds. Using preloaded reference genome, calling performed speed 200-300 thousand short reads (150 225 bases long) per second (25-40 MB/s BAM data). methylation reporting, running time complete task “BAM disk -> CX report disk” depends size BAM file, speed usually within range 30-50 MB/s (250-400 thousand short reads per second) single core relatively modern CPU (Intel(R) Core(TM) i7-7700). Major bottlenecks (BAM loading preprocessing) removed release v1.2, full multithreading minor improvements expected future.","code":""},{"path":"/articles/epialleleR.html","id":"sample-data","dir":"Articles","previous_headings":"","what":"Sample data","title":"The epialleleR User's Guide <img style=","text":"epialleleR package includes sample data, obtained using targeted sequencing. description assays files given . genomic coordinates external data files according GRCh38 reference assembly.","code":""},{"path":"/articles/epialleleR.html","id":"amplicon-based-methylation-ngs-data","dir":"Articles","previous_headings":"Sample data","what":"Amplicon-based methylation NGS data","title":"The epialleleR User's Guide <img style=","text":"samples Human HCT116 DKO Non-Methylated (Zymo Research, cat # D5014-1), Human HCT116 DKO Methylated (Zymo Research, cat # D5014-2) DNA,4 mix bisulfite-converted, BRCA1 gene promoter region amplified using four pairs primers. Amplicons mixed, indexed sequenced Illumina MiSeq system. related files :","code":""},{"path":"/articles/epialleleR.html","id":"capture-based-methylation-ngs-data","dir":"Articles","previous_headings":"Sample data","what":"Capture-based methylation NGS data","title":"The epialleleR User's Guide <img style=","text":"tumour DNA bisulfite-converted, fragmented hybridized custom-made probes covering promoter regions 283 tumour suppressor genes (described 5). Libraries sequenced using Illumina MiSeq system. related files :","code":""},{"path":"/articles/epialleleR.html","id":"manually-creating-sample-bam-files","dir":"Articles","previous_headings":"Sample data","what":"Manually creating sample BAM files","title":"The epialleleR User's Guide <img style=","text":"purposes testing package’s methods tools methylation calling /reporting, epialleleR provides convenient way manually create sample BAM files specifying mandatory optional BAM file tags. following code create small BAM file contains methylation calls can used methylation reporting described later: Check simulateBam method help page information parameters default values.","code":"bam.file <- tempfile(pattern=\"simulated\", fileext=\".bam\") simulateBam(output.bam.file=bam.file, XM=c(\"ZZzZZ\", \"zzZzz\"), XG=\"CT\") #> Writing sample BAM [0.007s] #> [1] 2 # one can view the resulting file using `samtools view -h <bam.file>` # or, if desired, file can be converted to SAM using `samtools view`, # manually corrected and converted back to BAM"},{"path":[]},{"path":"/articles/epialleleR.html","id":"requirements","dir":"Articles","previous_headings":"Typical workflow","what":"Requirements","title":"The epialleleR User's Guide <img style=","text":"mentioned earlier, epialleleR uses data stored Binary Alignment Map (BAM) files input currently allows load short-read (e.g., bisulfite) long-read (native) sequencing alignments. Specific requirements types data given . Additionally, please check preprocessBam function help file full description available parameters, well explanation function’s logic.","code":""},{"path":"/articles/epialleleR.html","id":"short-read-sequencing","dir":"Articles","previous_headings":"Typical workflow > Requirements","what":"Short-read sequencing","title":"The epialleleR User's Guide <img style=","text":"prerequisite records BAM file contain XG tag genomic strand map (“CT” “GA”), XM tag methylation call string — files produced mapping alignment tools Bismark Bisulfite Read Mapper Methylation Caller state---art Illumina solutions: Illumina DRAGEN Bio-Platform, Illumina Cloud analysis solutions, well contemporary Illumina sequencing instruments -board read mapping/alignment (NextSeq 1000/2000, NovaSeq X). BAM files contain necessary information can analysed without additional steps. BAM files produced mapping/alignment tools (e.g., bwa-meth BSMAP) lack XG/XM data, possible call methylation using callMethylation method. method add absent XG/XM tags save data output BAM file can analysed epialleleR.","code":""},{"path":"/articles/epialleleR.html","id":"long-read-sequencing","dir":"Articles","previous_headings":"Typical workflow > Requirements","what":"Long-read sequencing","title":"The epialleleR User's Guide <img style=","text":"preprocessing long reads, epialleleR requires presence MM (Mm) ML (Ml) tags hold information base modifications related probabilities, respectively. standard tags described SAM/BAM format specification, therefore relevant tools analysis alignment long sequencing reads able produce .","code":""},{"path":"/articles/epialleleR.html","id":"reading-the-data","dir":"Articles","previous_headings":"Typical workflow","what":"Reading the data","title":"The epialleleR User's Guide <img style=","text":"epialleleR methods can load BAM data using file path. However, file large several reports need prepared, advised use preprocessBam convenience function shown . function also used internally BAM file location string supplied input epialleleR methods. preprocessBam automatically determines BAM file contains paired- single-end alignments necessary tags (XM/XG) available. recommended use verbose processing check messages correct identification alignment endness. Otherwise, paired parameter set explicitly, exception thrown expected endness differs auto detected one. preprocessing paired-end alignments, paired reads merged according base quality: nucleotide base highest value QUAL string taken, unless quality less min.baseq, results information particular position (“-”/“N”). merged reads processed single entity epialleleR methods. Due merging, overlapping bases read pairs counted , base highest quality taken. requirement currently paired-end BAM file must sorted QNAME instead genomic location (.e., “unsorted”) perform merging paired-end reads. Error message shown sorted genomic location, case please sort QNAME using ‘samtools sort -n -o .bam .bam’. preprocessing single-end alignments, read merging performed. bases quality least min.baseq considered. Lower base quality results information particular position (“-”/“N”). RRBS-like protocols, possible trim alignments one ends. Trimming performed BAM loading therefore influence results downstream epialleleR methods. Internally, trimming performed level template (.e., read pair paired-end BAM individual read single-end BAM). ensures necessary parts (real ends sequenced fragment) removed paired-end sequencing reads.","code":""},{"path":"/articles/epialleleR.html","id":"specific-considerations-for-long-read-sequencing-data","dir":"Articles","previous_headings":"Typical workflow > Reading the data","what":"Specific considerations for long-read sequencing data:","title":"The epialleleR User's Guide <img style=","text":"location reported implicitly assumed contain modification. According SAM format specification, MM base modification tags allowed list modifications observed original sequenced strand (e.g., C+m) also opposite strand (e.g., G-m). logic processing follows (examples given ): * alignment record methylation modifications (neither C+m, G-m present), record , naturally, considered single read cytosines methylated * alignment record C+m modification (base modifications original sequenced strand), record , naturally, considered single read cytosine modifications sequenced strand * alignment record G-m modification (base modifications strand opposite sequenced), record treated two reads, original sequenced strand modifications, opposite strand cytosine modifications * C+m G-m present, record treated two reads, strands cytosine modifications","code":"library(epialleleR)  capture.bam <- system.file(\"extdata\", \"capture.bam\", package=\"epialleleR\") bam.data    <- preprocessBam(capture.bam) #> Checking BAM file: short-read, paired-end, name-sorted alignment detected #> Reading paired-end BAM file [0.014s]  # Specifics of long-read alignment processing out.bam <- tempfile(pattern=\"out-\", fileext=\".bam\") simulateBam(   seq=c(\"ACGCCATYCGCGCCA\"),   Mm=c(\"C+m,0,2,0;G-m,0,0,0;\"),   Ml=list(as.integer(c(102,128,153,138,101,96))),   output.bam.file=out.bam   ) #> Writing sample BAM [0.002s] #> [1] 1 generateCytosineReport(out.bam, threshold.reads=FALSE, report.context=\"CX\") #> Checking BAM file: long-read, single-end, unsorted alignment detected #> Reading single-end BAM file [0.001s] #> Preparing cytosine report [0.001s] #>      rname strand   pos context  meth unmeth #>     <fctr> <fctr> <int>  <fctr> <int>  <int> #>  1:   chrS      +     2      CG     1      0 #>  2:   chrS      -     3      CG     1      0 #>  3:   chrS      +     4     CHH     0      1 #>  4:   chrS      +     5     CHH     0      1 #>  5:   chrS      +     9      CG     1      0 #>  6:   chrS      -    10      CG     1      0 #>  7:   chrS      +    11      CG     1      0 #>  8:   chrS      -    12      CG     1      0 #>  9:   chrS      +    13     CHH     0      1 #> 10:   chrS      +    14     CHH     0      1"},{"path":"/articles/epialleleR.html","id":"optional-calling-of-cytosine-methylation","dir":"Articles","previous_headings":"Typical workflow","what":"Optional calling of cytosine methylation","title":"The epialleleR User's Guide <img style=","text":"short-read BAM file lacks XG/XM tags (e.g., output bwa-meth BSMAP), preprocessing fail message cytosine methylation calling must performed. can done follows:","code":"# bwa-meth sample output input.bam <- system.file(\"extdata\", \"test\", \"bwameth-se-unsort-yd.bam\", package=\"epialleleR\")  # resulting BAM with XG/XM tags output.bam <- tempfile(pattern=\"output-\", fileext=\".bam\")  # sample reference genome genome <- preprocessGenome(system.file(\"extdata\", \"test\", \"reference.fasta.gz\", package=\"epialleleR\")) #> Reading reference genome file [0.000s]  # calls cytosine methylation and stores it in the output BAM # Input BAM has 100 records of which 73 are mapped to the genome callMethylation(input.bam, output.bam, genome) #> Making methylation calls [0.022s] #> $nrecs #> [1] 100 #>  #> $ncalled #> [1] 73  # process this data further # bam.data <- preprocessBam(output.bam)"},{"path":"/articles/epialleleR.html","id":"making-cytosine-reports","dir":"Articles","previous_headings":"Typical workflow","what":"Making cytosine reports","title":"The epialleleR User's Guide <img style=","text":"epialleleR can generate conventional cytosine reports format, similar genome-wide cytosine report produced coverage2cytosine Bismark module.6 Please note generateCytosineReport produces thresholded (VEF) report default: methylated cytosines reads pass threshold (hypomethylated reads) counted unmethylated. order make conventional cytosine report, use threshold.reads=FALSE. produce conventional cytosine reports without thresholding within-context methylation level though minimally affected incomplete cytosine conversion, run method following parameters: threshold.reads=TRUE, threshold.context=\"CG\", min.context.sites=0, min.context.beta=0, max.outofcontext.beta=0.1. cytosines within reads (read pairs) 10% --context cytosines methylated, effectively treated unmethylated ones.","code":"# data.table::data.table object for # CpG VEF report cg.vef.report <- generateCytosineReport(bam.data) #> Thresholding reads [0.001s] #> Preparing cytosine report [0.013s] head(cg.vef.report[order(meth+unmeth, decreasing=TRUE)]) #>     rname strand      pos context  meth unmeth #>    <fctr> <fctr>    <int>  <fctr> <int>  <int> #> 1:  chr17      + 61864475      CG     7      9 #> 2:  chr17      + 61864486      CG    10      6 #> 3:  chr17      + 61864504      CG     9      7 #> 4:  chr20      - 57267455      CG    13      1 #> 5:  chr17      - 61863826      CG     0     13 #> 6:  chr17      - 61863830      CG     0     13  # CpG cytosine report cg.report <- generateCytosineReport(bam.data, threshold.reads=FALSE) #> Preparing cytosine report [0.014s] head(cg.report[order(meth+unmeth, decreasing=TRUE)]) #>     rname strand      pos context  meth unmeth #>    <fctr> <fctr>    <int>  <fctr> <int>  <int> #> 1:  chr17      + 61864475      CG     8      8 #> 2:  chr17      + 61864486      CG    10      6 #> 3:  chr17      + 61864504      CG    10      6 #> 4:  chr20      - 57267455      CG    13      1 #> 5:  chr17      - 61863826      CG     0     13 #> 6:  chr17      - 61863830      CG     0     13  # CX cytosine report cx.report <- generateCytosineReport(bam.data, threshold.reads=FALSE,                                     report.context=\"CX\") #> Preparing cytosine report [0.017s] head(cx.report[order(meth+unmeth, decreasing=TRUE)]) #>     rname strand      pos context  meth unmeth #>    <fctr> <fctr>    <int>  <fctr> <int>  <int> #> 1:  chr17      + 61864338     CHG     1     25 #> 2:  chr17      + 61864348     CHH     0     24 #> 3:  chr17      + 61864364     CHH     0     24 #> 4:  chr17      + 61864365     CHH     0     24 #> 5:  chr17      + 61864373     CHH     0     24 #> 6:  chr17      + 61864324     CHG     0     23"},{"path":"/articles/epialleleR.html","id":"making-vef-reports-for-a-set-of-genomic-regions","dir":"Articles","previous_headings":"Typical workflow","what":"Making VEF reports for a set of genomic regions","title":"The epialleleR User's Guide <img style=","text":"epialleleR allows make reports individual cytosine bases, also set genomic regions. especially useful targeted methylation sequencing used produce reads (amplicon sequencing hybridization capture using, e.g., Agilent SureSelect Target Enrichment Probes). amplicon sequencing principally differs capture-based assays coordinates reads known. Therefore, reads can assigned amplicons exact positions, capture targets — overlap. , epialleleR provides generic generateBedReport function well two aliases, generateAmpliconReport (amplicon-based NGS) generateCaptureReport (capture-based NGS).","code":"# report for amplicon-based data # matching is done by exact start or end positions plus/minus tolerance amplicon.report <- generateAmpliconReport(   bam=system.file(\"extdata\", \"amplicon010meth.bam\", package=\"epialleleR\"),   bed=system.file(\"extdata\", \"amplicon.bed\", package=\"epialleleR\") ) #> Reading BED file [0.032s] #> Checking BAM file: short-read, paired-end, name-sorted alignment detected #> Reading paired-end BAM file [0.005s] #> Thresholding reads [0.000s] #> Preparing amplicon report [0.044s] amplicon.report #>    seqnames    start      end width strand amplicon nreads+ nreads-        VEF #>      <fctr>    <int>    <int> <int> <fctr>   <char>   <int>   <int>      <num> #> 1:    chr17 43125624 43126026   403      * CpG00-13       0     156 0.08333333 #> 2:    chr17 43125270 43125640   371      * CpG14-31       0      61 0.11475410 #> 3:    chr17 43125171 43125550   380      * CpG17-34       0      93 0.05376344 #> 4:    chr17 43124861 43125249   389      * CpG33-49       0      84 0.10714286 #> 5:     <NA>       NA       NA    NA   <NA>     <NA>      60      46 0.13207547  # report for capture-based data # matching is done by overlap capture.report <- generateCaptureReport(   bam=system.file(\"extdata\", \"capture.bam\", package=\"epialleleR\"),   bed=system.file(\"extdata\", \"capture.bed\", package=\"epialleleR\") ) #> Reading BED file [0.008s] #> Checking BAM file: short-read, paired-end, name-sorted alignment detected #> Reading paired-end BAM file [0.014s] #> Thresholding reads [0.001s] #> Preparing capture report [0.015s] head(capture.report) #>    seqnames    start      end width strand     V4 nreads+ nreads-       VEF #>      <fctr>    <int>    <int> <int> <fctr> <char>   <int>   <int>     <num> #> 1:     chr1  3067647  3069703  2057      * PRDM16       2       1 1.0000000 #> 2:     chr1  3651039  3653096  2058      *   TP73       0       2 0.5000000 #> 3:     chr1  3689153  3691202  2050      *   TP73       0       2 1.0000000 #> 4:     chr1  3696519  3698570  2052      *   TP73       1       2 1.0000000 #> 5:     chr1  6179609  6181670  2062      *   CHD5       0       3 0.6666667 #> 6:     chr1 13698869 13699064   196      *  PRDM2      NA      NA        NA  # generateBedReport is a generic function for BED-guided reports bed.report <- generateBedReport(   bam=system.file(\"extdata\", \"capture.bam\", package=\"epialleleR\"),   bed=system.file(\"extdata\", \"capture.bed\", package=\"epialleleR\"),   bed.type=\"capture\" ) #> Reading BED file [0.007s] #> Checking BAM file: short-read, paired-end, name-sorted alignment detected #> Reading paired-end BAM file [0.013s] #> Thresholding reads [0.001s] #> Preparing capture report [0.015s] identical(capture.report, bed.report) #> [1] TRUE"},{"path":"/articles/epialleleR.html","id":"linearized-mhl-reports","dir":"Articles","previous_headings":"Typical workflow","what":"Linearized MHL reports","title":"The epialleleR User's Guide <img style=","text":"VEF values extremely useful detection mosaic epimutations. However, default thresholding parameters might fit nature regions interest. case, advised learn characteristics regions extractPatterns generateBedEcdf methods described . Alternatively, epialleleR provides method calculate metric similar VEF ability highlight hypermethylated regions require thresholding — linearised Methylated Haplotype Load (lMHL). lMHL modified version MHL (MHL first described Guo et al., 2017), sought faster applicable wider range sequencing data. information given help page generateMhlReport well values vignette.","code":"# lMHL report can be generated using mhl.report <- generateMhlReport(   bam=system.file(\"extdata\", \"capture.bam\", package=\"epialleleR\") ) #> Checking BAM file: short-read, paired-end, name-sorted alignment detected #> Reading paired-end BAM file [0.014s] #> Preparing lMHL report [0.022s]"},{"path":"/articles/epialleleR.html","id":"exploring-dna-methylation-patterns","dir":"Articles","previous_headings":"Typical workflow","what":"Exploring DNA methylation patterns","title":"The epialleleR User's Guide <img style=","text":"Individual epialleles can extracted plotted order visualize methylation patters within genomic region interest. , epialleleR provides methods extractPatterns plotPatterns can used follows:","code":"# First, let's extract base methylation information for sequencing reads # of 1:9 mix of methylated and non-methylated control DNA patterns <- extractPatterns(   bam=system.file(\"extdata\", \"amplicon010meth.bam\", package=\"epialleleR\"),   bed=as(\"chr17:43125200-43125600\",\"GRanges\") ) #> Checking BAM file: short-read, paired-end, name-sorted alignment detected #> Reading paired-end BAM file [0.005s] #> Extracting methylation patterns [0.020s]  # that many read pairs overlap genomic region of interest nrow(patterns) #> [1] 238  # now we can plot the most abundant them of them using default parameters plotPatterns(patterns) #> 238 patterns supplied #> 45 unique #> 9 most frequent unique patterns were selected for plotting using 10 beta value bins: #> [0,0.1) [0.1,0.2) [0.2,0.3) [0.3,0.4) [0.4,0.5) [0.5,0.6) [0.6,0.7) [0.7,0.8) [0.8,0.9) [0.9,1] #>       2         1         1         0         0         0         0         1         2       2 # now let's explore methylation patterns in RAD51C gene promoter using # methylation capture data capture.patterns <- extractPatterns(   bam=system.file(\"extdata\", \"capture.bam\", package=\"epialleleR\"),   bed=as(\"chr17:58691673-58693108\", \"GRanges\"),   verbose=FALSE )  # let's plot all the patterns using discrete genomic scale plotPatterns(capture.patterns, npatterns.per.bin=Inf,              genomic.scale=\"discrete\", context.size=1) #> 59 patterns supplied #> 56 unique #> 56 most frequent unique patterns were selected for plotting using 10 beta value bins: #> [0,0.1) [0.1,0.2) [0.2,0.3) [0.3,0.4) [0.4,0.5) [0.5,0.6) [0.6,0.7) [0.7,0.8) [0.8,0.9) [0.9,1] #>      22         3         1         2         3         1         2         0        11      11"},{"path":"/articles/epialleleR.html","id":"exploring-sequence-variants-in-epialleles","dir":"Articles","previous_headings":"Typical workflow","what":"Exploring sequence variants in epialleles","title":"The epialleleR User's Guide <img style=","text":"known sequence variants can affect methylation status DNA.7 generateVcfReport function calculates frequencies single nucleotide variants (SNVs) within epialleles tests association SNV epiallelic status using Fisher Exact test. Base counts test’s p-values included returned value. addition BAM file location string preprocessed BAM object, function requires location string Variant Call Format (VCF) file VCF object obtained using VariantAnnotation::readVcf function. VCF files can extremely large, strongly advised prefilter VCF object relevant set genomic regions, specify relevant set regions bed parameter vcf points VCF file location. Please note, output report currently limited SNVs . Also, default (min.baseq=0) output generateVcfReport equivalent one samtools mplieup -Q 0 ..., therefore may result false SNVs caused misalignments. Remember increase min.baseq (samtools mplieup -Q default value 13) obtain results higher quality.","code":"# VCF report vcf.report <- generateVcfReport(   bam=system.file(\"extdata\", \"amplicon010meth.bam\", package=\"epialleleR\"),   bed=system.file(\"extdata\", \"amplicon.bed\", package=\"epialleleR\"),   vcf=system.file(\"extdata\", \"amplicon.vcf.gz\", package=\"epialleleR\"),   # thresholds on alignment and base quality   min.mapq=30, min.baseq=13,   # when VCF seqlevels are different from BED and BAM it is possible   # to convert them internally   vcf.style=\"NCBI\" ) #> Loading required namespace: VariantAnnotation #> Reading BED file [0.027s] #> Reading VCF file [1.147s] #> Checking BAM file: short-read, paired-end, name-sorted alignment detected #> Reading paired-end BAM file [0.004s] #> Thresholding reads [0.000s] #> Extracting base frequences [0.037s]  # NA values are shown for the C->T variants on the \"+\" and G->A on the \"-\" # strands, because bisulfite conversion makes their counting impossible head(vcf.report) #>           name seqnames    range    REF    ALT M+Ref U+Ref M-Ref U-Ref M+Alt U+Alt M-Alt U-Alt #>         <char>   <fctr>    <int> <char> <char> <num> <num> <num> <num> <num> <num> <num> <num> #> 1: rs546660277    chr17 43124874      A      C     0     0     9    74     0     0     0     0 #> 2: rs574263814    chr17 43124891      G      A     0     0    NA    NA     0     0    NA    NA #> 3:   rs8176076    chr17 43124935      G      A     0     0    NA    NA     0     0    NA    NA #> 4: rs535977743    chr17 43125016      C      T    NA    NA     9    73    NA    NA     0     0 #> 5: rs191784032    chr17 43125050      C      A     0     0     9    73     0     0     0     1 #> 6: rs111956204    chr17 43125083      C      A     0     0     9    74     0     0     0     0 #>    SumRef SumAlt  FEp+  FEp- #>     <num>  <num> <num> <num> #> 1:     83      0     1     1 #> 2:      0      0     1    NA #> 3:      0      0     1    NA #> 4:     82      0    NA     1 #> 5:     82      1     1     1 #> 6:     83      0     1     1  # let's sort the report by increasing Fisher's exact test's p-values. # the p-values are given separately for reads that map to the \"+\" head(vcf.report[order(`FEp-`, na.last=TRUE)]) #>           name seqnames    range    REF    ALT M+Ref U+Ref M-Ref U-Ref M+Alt U+Alt M-Alt U-Alt #>         <char>   <fctr>    <int> <char> <char> <num> <num> <num> <num> <num> <num> <num> <num> #> 1: rs546660277    chr17 43124874      A      C     0     0     9    74     0     0     0     0 #> 2: rs535977743    chr17 43125016      C      T    NA    NA     9    73    NA    NA     0     0 #> 3: rs191784032    chr17 43125050      C      A     0     0     9    73     0     0     0     1 #> 4: rs111956204    chr17 43125083      C      A     0     0     9    74     0     0     0     0 #> 5:  rs55680227    chr17 43125086      A      C     0     0     8    64     0     0     0     0 #> 6: rs539733232    chr17 43125088      C      A     0     0     8    71     0     0     0     0 #>    SumRef SumAlt  FEp+  FEp- #>     <num>  <num> <num> <num> #> 1:     83      0     1     1 #> 2:     82      0    NA     1 #> 3:     82      1     1     1 #> 4:     83      0     1     1 #> 5:     72      0     1     1 #> 6:     79      0     1     1  # and to the \"-\" strand head(vcf.report[order(`FEp+`, na.last=TRUE)]) #>           name seqnames    range    REF    ALT M+Ref U+Ref M-Ref U-Ref M+Alt U+Alt M-Alt U-Alt #>         <char>   <fctr>    <int> <char> <char> <num> <num> <num> <num> <num> <num> <num> <num> #> 1: rs546660277    chr17 43124874      A      C     0     0     9    74     0     0     0     0 #> 2: rs574263814    chr17 43124891      G      A     0     0    NA    NA     0     0    NA    NA #> 3:   rs8176076    chr17 43124935      G      A     0     0    NA    NA     0     0    NA    NA #> 4: rs191784032    chr17 43125050      C      A     0     0     9    73     0     0     0     1 #> 5: rs111956204    chr17 43125083      C      A     0     0     9    74     0     0     0     0 #> 6:  rs55680227    chr17 43125086      A      C     0     0     8    64     0     0     0     0 #>    SumRef SumAlt  FEp+  FEp- #>     <num>  <num> <num> <num> #> 1:     83      0     1     1 #> 2:      0      0     1    NA #> 3:      0      0     1    NA #> 4:     82      1     1     1 #> 5:     83      0     1     1 #> 6:     72      0     1     1  # and finally, let's plot methylation patterns overlapping one of the most # covered SNPs in the methylation capture test data set - rs573296191 # (chr17:61864584) in BRIP1 gene brip1.patterns <- extractPatterns(   bam=system.file(\"extdata\", \"capture.bam\", package=\"epialleleR\"),   bed=as(\"chr17:61864583-61864585\", \"GRanges\"),   highlight.positions=61864584,   verbose=FALSE ) plotPatterns(brip1.patterns) #> 24 patterns supplied #> 17 unique #> 9 most frequent unique patterns were selected for plotting using 10 beta value bins: #> [0,0.1) [0.1,0.2) [0.2,0.3) [0.3,0.4) [0.4,0.5) [0.5,0.6) [0.6,0.7) [0.7,0.8) [0.8,0.9) [0.9,1] #>       2         0         0         1         0         1         2         1         0       2"},{"path":"/articles/epialleleR.html","id":"plotting-the-distribution-of-per-read-beta-values","dir":"Articles","previous_headings":"Typical workflow","what":"Plotting the distribution of per-read beta values","title":"The epialleleR User's Guide <img style=","text":"stated introduction, human genomic DNA regions often show bimodal methylation patterns. epialleleR allows visualize information plotting empirical cumulative distribution functions (eCDFs) within- --context beta values. code produces plots sequencing reads control DNA samples. Note within--context eCDF(0.5) values close expected 1-VEF values corresponding control DNA samples: non-methylated DNA — expected VEF = 0, observed 1-eCDF(0.5) ≈ 0 1:9 mix methylated non-methylated DNA — expected VEF = 0.1, observed 1-eCDF(0.5) ≈ 0.1 fully methylated DNA — expected VEF = 1, observed 1-eCDF(0.5) ≈ 1","code":"# First, let's visualise eCDFs for within- and out-of-context beta values # for all four amplicons and unmatched reads. Note that within-the-context eCDF # of 0.5 is very close to the expected 1-VEF value (0.1) for all amplicons # produced from this 1:9 mix of methylated and non-methylated control DNA  # let's compute eCDF amplicon.ecdfs <- generateBedEcdf(   bam=system.file(\"extdata\", \"amplicon010meth.bam\", package=\"epialleleR\"),   bed=system.file(\"extdata\", \"amplicon.bed\", package=\"epialleleR\"),   bed.rows=NULL ) #> Reading BED file [0.008s] #> Checking BAM file: short-read, paired-end, name-sorted alignment detected #> Reading paired-end BAM file [0.005s] #> Computing ECDFs for within- and out-of-context per-read beta values [0.006s]  # there are 5 items in amplicon.ecdfs, let's plot all of them par(mfrow=c(1,length(amplicon.ecdfs)))  # cycle through items for (x in 1:length(amplicon.ecdfs)) {   # four of them have names corresponding to genomic regions of amplicon.bed   # fifth - NA for all the reads that don't match to any of those regions   main <- if (is.na(names(amplicon.ecdfs[x]))) \"unmatched\"           else names(amplicon.ecdfs[x])      # plotting eCDF for within-the-context per-read beta values (in red)   plot(amplicon.ecdfs[[x]]$context, col=\"red\", verticals=TRUE, do.points=FALSE,        xlim=c(0,1), xlab=\"per-read beta value\", ylab=\"cumulative density\",        main=main)      # adding eCDF for out-of-context per-read beta values (in blue)   plot(amplicon.ecdfs[[x]]$out.of.context, add=TRUE, col=\"blue\",        verticals=TRUE, do.points=FALSE) } # Second, let's compare eCDFs for within-the-context beta values for only one # amplicon but all three sequenced samples: pure non-methylated DNA, 1:9 mix of # methylated and non-methylated DNA, and fully methylated DNA  # our files bam.files <- c(\"amplicon000meth.bam\", \"amplicon010meth.bam\",                \"amplicon100meth.bam\")  # let's plot all of them par(mfrow=c(1,length(bam.files)))  # cycle through items for (f in bam.files) {   # let's compute eCDF   amplicon.ecdfs <- generateBedEcdf(     bam=system.file(\"extdata\", f, package=\"epialleleR\"),     bed=system.file(\"extdata\", \"amplicon.bed\", package=\"epialleleR\"),     # only the second amplicon     bed.rows=2, verbose=FALSE   )      # plotting eCDF for within-the-context per-read beta values (in red)   plot(amplicon.ecdfs[[1]]$context, col=\"red\", verticals=TRUE, do.points=FALSE,        xlim=c(0,1), xlab=\"per-read beta value\", ylab=\"cumulative density\",        main=f)       # adding eCDF for out-of-context per-read beta values (in blue)   plot(amplicon.ecdfs[[1]]$out.of.context, add=TRUE, col=\"blue\",        verticals=TRUE, do.points=FALSE) }"},{"path":[]},{"path":"/articles/epialleleR.html","id":"citing-the-epialleler-package","dir":"Articles","previous_headings":"Other information","what":"Citing the epialleleR package","title":"The epialleleR User's Guide <img style=","text":"Oleksii Nikolaienko, Per Eystein Lønning, Stian Knappskog, epialleleR: R/Bioconductor package sensitive allele-specific methylation analysis NGS data. GigaScience, Volume 12, 2023, giad087, https://doi.org/10.1093/gigascience/giad087","code":""},{"path":"/articles/epialleleR.html","id":"the-data-underlying-epialleler-manuscript","dir":"Articles","previous_headings":"Other information","what":"The data underlying epialleleR manuscript","title":"The epialleleR User's Guide <img style=","text":"Replication Data : “epialleleR: R/BioC package quantifying analysing low-frequency DNA methylation”, https://doi.org/10.18710/2BQTJP NCBI GEO dataset GSE201690: “Methylation analysis promoter regions selected tumour suppressor genes DNA white blood cells”, https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE201690","code":""},{"path":"/articles/epialleleR.html","id":"our-experimental-studies-that-use-the-package","dir":"Articles","previous_headings":"Other information","what":"Our experimental studies that use the package","title":"The epialleleR User's Guide <img style=","text":"Per Eystein Lonning, Oleksii Nikolaienko, Kathy Pan, Allison W. Kurian, Hans Petter Petter Eikesdal, Mary Pettinger, Garnet L Anderson, Ross L Prentice, Rowan T. Chlebowski, Stian Knappskog. Constitutional BRCA1 methylation risk incident triple-negative breast cancer high-grade serous ovarian cancer. JAMA Oncology 2022. https://doi.org/10.1001/jamaoncol.2022.3846 Oleksii Nikolaienko, Hans P. Eikesdal, Elisabet Ognedal, Bjørnar Gilje, Steinar Lundgren, Egil S. Blix, Helge Espelid, Jürgen Geisler, Stephanie Geisler, Emiel .M. Janssen, Synnøve Yndestad, Laura Minsaas, Beryl Leirvaag, Reidun Lillestøl, Stian Knappskog, Per E. Lønning. Prenatal BRCA1 epimutations contribute significantly triple-negative breast cancer development. Genome Medicine 2023. https://doi.org/10.1186/s13073-023-01262-8. Data: GSE243966","code":""},{"path":"/articles/epialleleR.html","id":"session-info","dir":"Articles","previous_headings":"Other information","what":"Session Info","title":"The epialleleR User's Guide <img style=","text":"","code":"sessionInfo() #> R version 4.4.1 (2024-06-14) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               LC_TIME=en_US.UTF-8        #>  [4] LC_COLLATE=en_US.UTF-8     LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    #>  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  LC_ADDRESS=C               #> [10] LC_TELEPHONE=C             LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] ggplot2_3.5.1     epialleleR_1.13.4 #>  #> loaded via a namespace (and not attached): #>  [1] tidyselect_1.2.1            dplyr_1.1.4                 farver_2.1.2                #>  [4] blob_1.2.4                  Biostrings_2.73.2           bitops_1.0-9                #>  [7] RCurl_1.98-1.16             fastmap_1.2.0               VariantAnnotation_1.51.1    #> [10] GenomicAlignments_1.41.0    XML_3.99-0.17               digest_0.6.37               #> [13] lifecycle_1.0.4             KEGGREST_1.45.1             RSQLite_2.3.7               #> [16] magrittr_2.0.3              compiler_4.4.1              rlang_1.1.4                 #> [19] sass_0.4.9                  tools_4.4.1                 utf8_1.2.4                  #> [22] yaml_2.3.10                 data.table_1.16.0           rtracklayer_1.65.0          #> [25] knitr_1.48                  S4Arrays_1.5.10             labeling_0.4.3              #> [28] htmlwidgets_1.6.4           bit_4.5.0                   curl_5.2.3                  #> [31] DelayedArray_0.31.14        abind_1.4-8                 BiocParallel_1.39.0         #> [34] withr_3.0.1                 BiocGenerics_0.51.3         desc_1.4.3                  #> [37] grid_4.4.1                  stats4_4.4.1                fansi_1.0.6                 #> [40] colorspace_2.1-1            scales_1.3.0                SummarizedExperiment_1.35.3 #> [43] cli_3.6.3                   rmarkdown_2.28              crayon_1.5.3                #> [46] ragg_1.3.3                  generics_0.1.3              rjson_0.2.23                #> [49] httr_1.4.7                  DBI_1.2.3                   cachem_1.1.0                #> [52] zlibbioc_1.51.1             parallel_4.4.1              AnnotationDbi_1.67.0        #> [55] XVector_0.45.0              restfulr_0.0.15             matrixStats_1.4.1           #> [58] vctrs_0.6.5                 Matrix_1.7-0                jsonlite_1.8.9              #> [61] IRanges_2.39.2              S4Vectors_0.43.2            bit64_4.5.2                 #> [64] systemfonts_1.1.0           GenomicFeatures_1.57.1      jquerylib_0.1.4             #> [67] glue_1.8.0                  pkgdown_2.1.1.9000          codetools_0.2-20            #> [70] gtable_0.3.5                GenomeInfoDb_1.41.2         BiocIO_1.15.2               #> [73] GenomicRanges_1.57.1        UCSC.utils_1.1.0            munsell_0.5.1               #> [76] tibble_3.2.1                pillar_1.9.0                htmltools_0.5.8.1           #> [79] BSgenome_1.73.1             GenomeInfoDbData_1.2.13     R6_2.5.1                    #> [82] textshaping_0.4.0           evaluate_1.0.0              lattice_0.22-6              #> [85] Biobase_2.65.1              highr_0.11                  png_0.1-8                   #> [88] Rsamtools_2.21.2            memoise_2.0.1               bslib_0.8.0                 #> [91] Rcpp_1.0.13                 SparseArray_1.5.44          xfun_0.48                   #> [94] fs_1.6.4                    MatrixGenerics_1.17.0       pkgconfig_2.0.3"},{"path":[]},{"path":"/articles/values.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"The epialleleR output values <img style=","text":"best possible explanation VEF lMHL values given help files generateCytosineReport generateMhlReport methods, respectively. try show simplified real situations, .e., different methylation patterns may exist, provide visual summary epialleleR output. readers welcome try real simulated data. might interest others, please create issue examples might get included vignette. NB: plotMetrics function used piece spaghetti code, hence hidden. still want use see - browse source code vignette online.","code":"out.bam <- tempfile(pattern=\"simulated\", fileext=\".bam\") set.seed(1)  # no epimutations simulateBam(   output.bam.file=out.bam,   XM=c(     sapply(       lapply(1:1000, function (x) sample(c(\"Z\",rep(\"z\", 9)), 10)),       paste, collapse=\"\"     )   ),   XG=\"CT\" ) #> Writing sample BAM [0.127s] #> [1] 1000 plotMetrics(out.bam, as(\"chrS:1-10\", \"GRanges\"), 0, title=\"no epimutations\") # one complete epimutation simulateBam(   output.bam.file=out.bam,   XM=c(     paste(rep(\"Z\", 10), collapse=\"\"),     sapply(       lapply(1:999, function (x) sample(c(\"Z\",rep(\"z\", 9)), 10)),       paste, collapse=\"\"     )   ),   XG=\"CT\" ) #> Writing sample BAM [0.100s] #> [1] 1000 plotMetrics(out.bam, as(\"chrS:1-10\", \"GRanges\"), title=\"one complete epimutation\") # one partial epimutation simulateBam(   output.bam.file=out.bam,   XM=c(     paste(c(rep(\"Z\", 4), \"z\", \"z\", rep(\"Z\", 4)), collapse=\"\"),     sapply(       lapply(1:999, function (x) sample(c(\"Z\",rep(\"z\", 9)), 10)),       paste, collapse=\"\"     )   ),   XG=\"CT\" ) #> Writing sample BAM [0.101s] #> [1] 1000 plotMetrics(out.bam, as(\"chrS:1-10\", \"GRanges\"), title=\"one partial epimutation\") # another partial epimutation simulateBam(   output.bam.file=out.bam,   XM=c(     \"zZZZZZZZzz\",     sapply(       lapply(1:999, function (x) sample(c(\"Z\",rep(\"z\", 9)), 10)),       paste, collapse=\"\"     )   ),   XG=\"CT\" ) #> Writing sample BAM [0.108s] #> [1] 1000 plotMetrics(out.bam, as(\"chrS:1-10\", \"GRanges\"), title=\"another partial epimutation\") # several partial epimutations simulateBam(   output.bam.file=out.bam,   XM=c(     sapply(       lapply(1:10, function (x) c(rep(\"Z\", 6), rep(\"z\", 4))),       paste, collapse=\"\"     ),     sapply(       lapply(1:999, function (x) sample(c(\"Z\",rep(\"z\", 9)), 10)),       paste, collapse=\"\"     )   ),   XG=\"CT\" ) #> Writing sample BAM [0.098s] #> [1] 1009 plotMetrics(out.bam, as(\"chrS:1-10\", \"GRanges\"), title=\"several partial epimutations\") # several short partial epimutations simulateBam(   output.bam.file=out.bam,   XM=c(     sapply(       lapply(1:10, function (x) c(rep(\"Z\", 4), rep(\"z\", 6))),       paste, collapse=\"\"     ),     sapply(       lapply(1:999, function (x) sample(c(\"Z\",rep(\"z\", 9)), 10)),       paste, collapse=\"\"     )   ),   XG=\"CT\" ) #> Writing sample BAM [0.098s] #> [1] 1009 plotMetrics(out.bam, as(\"chrS:1-10\", \"GRanges\"), title=\"several short partial epimutations\") # several overlapping partial epimutations simulateBam(   output.bam.file=out.bam,   pos=1:10,   XM=c(     \"ZZZZZZZZZZ\", \"ZZZZZZZZZz\", \"ZZZZZZZZzz\", \"ZZZZZZZzzz\", \"ZZZZZZzzzz\",     sapply(       lapply(1:15, function (x) sample(c(\"Z\",rep(\"z\", 9)), 10)),       paste, collapse=\"\"     )   ),   XG=\"CT\" ) #> Writing sample BAM [0.004s] #> [1] 20 plotMetrics(out.bam, as(\"chrS:1-20\", \"GRanges\"), title=\"several overlapping partial epimutations\") # amplicon 0% plotMetrics(   system.file(\"extdata\", \"amplicon000meth.bam\", package=\"epialleleR\"),   as(\"chr17:43124861-43126026\", \"GRanges\"), title=\"amplicon, 0%\" ) # amplicon 10% plotMetrics(   system.file(\"extdata\", \"amplicon010meth.bam\", package=\"epialleleR\"),   as(\"chr17:43124861-43126026\", \"GRanges\"), title=\"amplicon, 10%\" ) # sample capture, BMP7 plotMetrics(   system.file(\"extdata\", \"capture.bam\", package=\"epialleleR\"),   as(\"chr20:57266125-57268185:+\", \"GRanges\"), title=\"sample capture, BMP7, + strand\" ) # sample capture, BMP7 plotMetrics(   system.file(\"extdata\", \"capture.bam\", package=\"epialleleR\"),   as(\"chr20:57266125-57268185:-\", \"GRanges\"), title=\"sample capture, BMP7, - strand\" ) # sample capture, RAD51C plotMetrics(   system.file(\"extdata\", \"capture.bam\", package=\"epialleleR\"),   as(\"chr17:58691673-58693108:+\", \"GRanges\"), title=\"sample capture, RAD51C, + strand\" ) # sample capture, RAD51C plotMetrics(   system.file(\"extdata\", \"capture.bam\", package=\"epialleleR\"),   as(\"chr17:58691673-58693108:-\", \"GRanges\"), title=\"sample capture, RAD51C, - strand\" ) # long-read sequencing, low methylation getXM <- function (p) {sample(x=c(\"z\", \"Z\"), size=1, prob=c(p, 1-p))} probs <- (sin(seq(-2*pi, +1*pi, by = pi/25))+2)/3 simulateBam(   output.bam.file=out.bam,   pos=1:10,   XM=sapply(1:10, function (i) {paste(sapply(probs, getXM), collapse=\"\")}),   XG=\"CT\" ) #> Writing sample BAM [0.012s] #> [1] 10 plotMetrics(out.bam, as(\"chrS:1-1000\", \"GRanges\"), title=\"long-read sequencing, low methylation\") # long-read sequencing, high methylation simulateBam(   output.bam.file=out.bam,   pos=1:10,   XM=sapply(1:10, function (i) {paste(sapply(1-probs, getXM), collapse=\"\")}),   XG=\"CT\" ) #> Writing sample BAM [0.016s] #> [1] 10 plotMetrics(out.bam, as(\"chrS:1-1000\", \"GRanges\"), title=\"long-read sequencing, high methylation\")"},{"path":"/articles/values.html","id":"session-info","dir":"Articles","previous_headings":"Introduction","what":"Session Info","title":"The epialleleR output values <img style=","text":"","code":"sessionInfo() #> R version 4.4.1 (2024-06-14) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.5 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               LC_TIME=en_US.UTF-8        #>  [4] LC_COLLATE=en_US.UTF-8     LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8    #>  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  LC_ADDRESS=C               #> [10] LC_TELEPHONE=C             LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C        #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] epialleleR_1.13.4    ggplot2_3.5.1        GenomicRanges_1.57.1 GenomeInfoDb_1.41.2  #> [5] IRanges_2.39.2       S4Vectors_0.43.2     BiocGenerics_0.51.3  data.table_1.16.0    #>  #> loaded via a namespace (and not attached): #>  [1] sass_0.4.9              utf8_1.2.4              generics_0.1.3          digest_0.6.37           #>  [5] magrittr_2.0.3          RColorBrewer_1.1-3      evaluate_1.0.0          grid_4.4.1              #>  [9] fastmap_1.2.0           jsonlite_1.8.9          httr_1.4.7              fansi_1.0.6             #> [13] UCSC.utils_1.1.0        scales_1.3.0            textshaping_0.4.0       jquerylib_0.1.4         #> [17] cli_3.6.3               rlang_1.1.4             XVector_0.45.0          munsell_0.5.1           #> [21] withr_3.0.1             cachem_1.1.0            yaml_2.3.10             tools_4.4.1             #> [25] dplyr_1.1.4             colorspace_2.1-1        GenomeInfoDbData_1.2.13 vctrs_0.6.5             #> [29] R6_2.5.1                lifecycle_1.0.4         zlibbioc_1.51.1         fs_1.6.4                #> [33] htmlwidgets_1.6.4       ragg_1.3.3              pkgconfig_2.0.3         desc_1.4.3              #> [37] pkgdown_2.1.1.9000      bslib_0.8.0             pillar_1.9.0            gtable_0.3.5            #> [41] glue_1.8.0              Rcpp_1.0.13             systemfonts_1.1.0       highr_0.11              #> [45] xfun_0.48               tibble_3.2.1            tidyselect_1.2.1        knitr_1.48              #> [49] farver_2.1.2            htmltools_0.5.8.1       rmarkdown_2.28          labeling_0.4.3          #> [53] compiler_4.4.1"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Oleksii Nikolaienko. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Oleksii Nikolaienko, Per Eystein Lønning, Stian Knappskog. epialleleR: R/Bioconductor package sensitive allele-specific methylation analysis NGS data. GigaScience, Volume 12, 2023, giad087, https://doi.org/10.1093/gigascience/giad087","code":"@Article{,   title = {epialleleR: an R/Bioconductor package for sensitive allele-specific methylation analysis in NGS data},   author = {Oleksii Nikolaienko and Per Eystein Lønning and Stian Knappskog},   journal = {GigaScience},   volume = {12},   pages = {giad087},   year = {2023},   month = {10},   url = {https://doi.org/10.1093/gigascience/giad087}, }"},{"path":[]},{"path":"/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"Fast, Epiallele-Aware Methylation Caller and Reporter","text":"epialleleR R package calling reporting cytosine methylation hypermethylated variant epiallele frequencies (VEF) level genomic regions individual cytosines next-generation sequencing data using binary alignment map (BAM) files input. See additional functionality.","code":""},{"path":"/index.html","id":"current-features","dir":"","previous_headings":"Introduction","what":"Current Features","title":"Fast, Epiallele-Aware Methylation Caller and Reporter","text":"calling cytosine methylation saving calls BAM file (callMethylation) creating sample BAM files given mandatory optional BAM fields (simulateBam) conventional reporting cytosine methylation (generateCytosineReport) reporting hypermethylated variant epiallele frequency (VEF) level genomic regions (generate[Bed|Amplicon|Capture]Report) individual cytosines (generateCytosineReport) reporting linearised Methylated Haplotype Load (lMHL, generateMhlReport) extracting methylation patterns genomic region interest (extractPatterns) visualising methylation patterns (plotPatterns) testing association epiallele methylation status sequence variations (generateVcfReport) assessing distribution per-read beta values genomic regions interest (generateBedEcdf)","code":""},{"path":[]},{"path":"/index.html","id":"v114-bioc-320","dir":"","previous_headings":"Introduction > Recent improvements","what":"v1.14 [BioC 3.20]","title":"Fast, Epiallele-Aware Methylation Caller and Reporter","text":"creates pretty plots methylation patterns","code":""},{"path":"/index.html","id":"v112-bioc-319","dir":"","previous_headings":"Introduction > Recent improvements","what":"v1.12 [BioC 3.19]","title":"Fast, Epiallele-Aware Methylation Caller and Reporter","text":"inputs long-read sequencing alignments full support short-read sequencing alignments Illumina DRAGEN, Bismark, bwa-meth, BSMAP RRBS-specific options lower memory usage","code":""},{"path":"/index.html","id":"v110-bioc-318","dir":"","previous_headings":"Introduction > Recent improvements","what":"v1.10 [BioC 3.18]","title":"Fast, Epiallele-Aware Methylation Caller and Reporter","text":"inputs single-end paired-end sequencing alignments makes stores methylation calls creates sample BAM files reports linearised MHL","code":""},{"path":"/index.html","id":"v14-bioc-315","dir":"","previous_headings":"Introduction > Recent improvements","what":"v1.4 [BioC 3.15]","title":"Fast, Epiallele-Aware Methylation Caller and Reporter","text":"significant speed-method extract visualize methylation patterns","code":""},{"path":"/index.html","id":"v12-bioc-314","dir":"","previous_headings":"Introduction > Recent improvements","what":"v1.2 [BioC 3.14]","title":"Fast, Epiallele-Aware Methylation Caller and Reporter","text":"even faster memory-efficient BAM loading (means HTSlib) min.baseq parameter reduce effect low quality bases methylation SNV calling (v1.0 output generateVcfReport equivalent one samtools mpileup -Q 0 ...) check NEWS !","code":""},{"path":[]},{"path":"/index.html","id":"install-via-bioconductor","dir":"","previous_headings":"Installation","what":"install via Bioconductor","title":"Fast, Epiallele-Aware Methylation Caller and Reporter","text":"","code":"if (!requireNamespace(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\")  BiocManager::install(\"epialleleR\")"},{"path":"/index.html","id":"install-the-latest-version-via-install_github","dir":"","previous_headings":"Installation","what":"Install the latest version via install_github","title":"Fast, Epiallele-Aware Methylation Caller and Reporter","text":"","code":"library(devtools) install_github(\"BBCG/epialleleR\", build_vignettes=FALSE,   repos=BiocManager::repositories(),   dependencies=TRUE, type=\"source\")"},{"path":"/index.html","id":"using-the-package","dir":"","previous_headings":"","what":"Using the package","title":"Fast, Epiallele-Aware Methylation Caller and Reporter","text":"Please read epialleleR vignette GitHub pages within R environment: vignette(\"epialleleR\", package=\"epialleleR\"), consult function’s help pages extensive information usage, parameters output values. Comparison beta, VEF lMHL values various use cases given values vignette (vignette(\"values\", package=\"epialleleR\")) brief synopsis:","code":"library(epialleleR)  # make methylation calls if necessary callMethylation(   input.bam.file=system.file(\"extdata\", \"test\", \"dragen-se-unsort-xg.bam\", package=\"epialleleR\"),   output.bam.file=tempfile(pattern=\"output-\", fileext=\".bam\"),   genome=system.file(\"extdata\", \"test\", \"reference.fasta.gz\", package=\"epialleleR\") )  # make a sample BAM file from scratch simulateBam(output.bam.file=tempfile(pattern=\"simulated-\", fileext=\".bam\"),             pos=c(1, 2), XM=c(\"ZZZzzZZZ\", \"ZZzzzzZZ\"), XG=c(\"CT\", \"AG\"))  # or use external files amplicon.bam <- system.file(\"extdata\", \"amplicon010meth.bam\",                             package=\"epialleleR\") amplicon.bed <- system.file(\"extdata\", \"amplicon.bed\", package=\"epialleleR\") amplicon.vcf <- system.file(\"extdata\", \"amplicon.vcf.gz\", package=\"epialleleR\")  # preload the data bam.data <- preprocessBam(amplicon.bam)  # methylation patterns and their plot patterns <- extractPatterns(bam=amplicon.bam, bed=amplicon.bed, bed.row=3) plotPatterns(patterns)  # CpG VEF report for individual bases cg.vef.report <- generateCytosineReport(bam.data)  # BED-guided VEF report for genomic ranges bed.report <- generateBedReport(bam=amplicon.bam, bed=amplicon.bed,                                 bed.type=\"capture\")  # VCF report vcf.report <- generateVcfReport(bam=amplicon.bam, bed=amplicon.bed,                                 vcf=amplicon.vcf, vcf.style=\"NCBI\")  # lMHL report mhl.report <- generateMhlReport(bam=amplicon.bam)"},{"path":"/index.html","id":"citing-the-epialleler-package","dir":"","previous_headings":"Using the package","what":"Citing the epialleleR package","title":"Fast, Epiallele-Aware Methylation Caller and Reporter","text":"Oleksii Nikolaienko, Per Eystein Lønning, Stian Knappskog, epialleleR: R/Bioconductor package sensitive allele-specific methylation analysis NGS data. GigaScience, Volume 12, 2023, giad087, https://doi.org/10.1093/gigascience/giad087. Data: GSE201690","code":""},{"path":"/index.html","id":"our-experimental-studies-that-use-the-package","dir":"","previous_headings":"Using the package","what":"Our experimental studies that use the package","title":"Fast, Epiallele-Aware Methylation Caller and Reporter","text":"Per Eystein Lonning, Oleksii Nikolaienko, Kathy Pan, Allison W. Kurian, Hans Petter Petter Eikesdal, Mary Pettinger, Garnet L Anderson, Ross L Prentice, Rowan T. Chlebowski, Stian Knappskog. Constitutional BRCA1 methylation risk incident triple-negative breast cancer high-grade serous ovarian cancer. JAMA Oncology 2022. https://doi.org/10.1001/jamaoncol.2022.3846 Oleksii Nikolaienko, Hans P. Eikesdal, Elisabet Ognedal, Bjørnar Gilje, Steinar Lundgren, Egil S. Blix, Helge Espelid, Jürgen Geisler, Stephanie Geisler, Emiel .M. Janssen, Synnøve Yndestad, Laura Minsaas, Beryl Leirvaag, Reidun Lillestøl, Stian Knappskog, Per E. Lønning. Prenatal BRCA1 epimutations contribute significantly triple-negative breast cancer development. Genome Medicine 2023. https://doi.org/10.1186/s13073-023-01262-8. Data: GSE243966","code":""},{"path":"/index.html","id":"epialleler-at-bioconductor","dir":"","previous_headings":"Using the package","what":"epialleleR at Bioconductor","title":"Fast, Epiallele-Aware Methylation Caller and Reporter","text":"release, development version","code":""},{"path":"/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Fast, Epiallele-Aware Methylation Caller and Reporter","text":"Artistic License 2.0","code":""},{"path":"/reference/callMethylation.html","id":null,"dir":"Reference","previous_headings":"","what":"callMethylation — callMethylation","title":"callMethylation — callMethylation","text":"function calls cytosine methylation stores calls BAM files.","code":""},{"path":"/reference/callMethylation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"callMethylation — callMethylation","text":"","code":"callMethylation(   input.bam.file,   output.bam.file,   genome,   nthreads = 1,   verbose = TRUE )"},{"path":"/reference/callMethylation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"callMethylation — callMethylation","text":"input.bam.file input BAM file location string. output.bam.file output BAM file location string. genome reference (genomic) sequences file location string output preprocessGenome. nthreads non-negative integer number additional HTSlib threads used file decompression (default: 1). verbose boolean report progress timings (default: TRUE).","code":""},{"path":"/reference/callMethylation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"callMethylation — callMethylation","text":"list object simple statistics processed (\"nrecs\") records calls made (\"ncalled\"). Even though \"ncalled\" can less \"nrecs\" (e.g., reads mapped), records input BAM written output BAM.","code":""},{"path":"/reference/callMethylation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"callMethylation — callMethylation","text":"function makes cytosine methylation calls short-read methylation (bisulfite/enzymatic) sequencing alignments input BAM file writes XM tag output BAM file. Calls made basis reference (e.g., genomic) sequence observed sequence cytosine context reads. Data reading/processing done means HTSlib, therefore possible significantly (>5x) speed calling using several (4-8) HTSlib decompression threads. Methylation calling function possible sequencing data obtained using either bisulfite similar sequencing method (enzymatic methylation sequencing). Cytosine methylation long-read, native DNA sequencing alignments called using , appropriate tools. requirement genomic strand read aligned known. information typically stored XG tag Bismark/Illumina BAM files, YD tag BWA-meth alignment files, ZS tag BSMAP alignment files. `epialleleR` aware use whichever tag available. sequence context cytosines (h/H \"CHH\", x/X \"CHG\", z/Z \"CG\") determined based actual (observed) sequence read. E.g., read \"ACGT\" aligned forward strand reference sequence \"ACaaGT\" CIGAR string \"2M2D2M\" (2 bases match, 2 reference bases deleted, 2 bases match), methylation call string \".Z..\" (contrast reference's one \".H....\"). makes cytosine calls nearly identical ones produced Bismark Bisulfite Read Mapper Methylation Caller Illumina DRAGEN Bio Platform, however one important distinction: `epialleleR` reports sequence context cytosines followed unknown bases (\"CNN\") \"H..\" instead \"U..\" (unknown; example Illumina DRAGEN Bio Platform ). Similarly, forward strand context \"CNG\" reported \"X..\", forward strand context \"CGN\" -> \"Z..\", reverse strand context \"NNG\" -> \"..H\", reverse strand context \"CNG\" -> \"..X\", reverse strand context \"NCG\" -> \"..Z\". lowercase uppercase ACGTN symbols reference sequence allowed correctly recognised, however symbols (e.g., extended IUPAC symbols, MRSVWYHKDB) within sequences converted N. reference sequence, function expects either location (preferably `bgzip`ped) FASTA file object obtained preprocessGenome. latter recommended methylation calling performed multiple BAM files. alignment records output BAM file contain additional XM tag methylation call string every mapped read XM tag available. Besides , XG tag reference sequence strand (\"CT\" \"GA\") added reads case present. Please note purpose methylation calling, reference genome must used alignment (BAM produced) calling cytosine methylation callMethylation method. Exception thrown reference sequence header BAM file match reference sequence data provided (matching performed basis names lengths reference sequences).","code":""},{"path":[]},{"path":"/reference/callMethylation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"callMethylation — callMethylation","text":"","code":"callMethylation(     input.bam.file=system.file(\"extdata\", \"test\", \"dragen-se-unsort-xg.bam\", package=\"epialleleR\"),     output.bam.file=tempfile(pattern=\"output-\", fileext=\".bam\"),     genome=system.file(\"extdata\", \"test\", \"reference.fasta.gz\", package=\"epialleleR\")   ) #> Reading reference genome file  #> [0.000s] #> Making methylation calls  #> [0.022s] #> $nrecs #> [1] 100 #>  #> $ncalled #> [1] 100 #>"},{"path":"/reference/extractPatterns.html","id":null,"dir":"Reference","previous_headings":"","what":"extractPatterns — extractPatterns","title":"extractPatterns — extractPatterns","text":"function extracts methylation patterns (epialleles) given genomic region interest.","code":""},{"path":"/reference/extractPatterns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"extractPatterns — extractPatterns","text":"","code":"extractPatterns(   bam,   bed,   bed.row = 1,   zero.based.bed = FALSE,   match.min.overlap = 1,   extract.context = c(\"CG\", \"CHG\", \"CHH\", \"CxG\", \"CX\"),   min.context.freq = 0.01,   clip.patterns = FALSE,   strand.offset = c(CG = 1, CHG = 2, CHH = 0, CxG = 0, CX = 0)[extract.context],   highlight.positions = c(),   ...,   verbose = TRUE )"},{"path":"/reference/extractPatterns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"extractPatterns — extractPatterns","text":"bam BAM file location string preprocessed output preprocessBam function. Read BAM file requirements BAM preprocessing preprocessBam. bed Browser Extensible Data (BED) file location string object class GRanges holding genomic coordinates regions interest. used match sequencing reads genomic regions pattern extraction. style seqlevels BED file/object must match style seqlevels BAM file/object used. BED/GRanges rows sorted internally. now, strand information ignored patterns matching strands extracted. bed.row single non-negative integer specifying `bed` region included output (default: 1). zero.based.bed boolean defining BED coordinates zero based (default: FALSE). match.min.overlap integer smallest overlap read's BED/GRanges start end positions matching capture-based NGS reads (default: 1). extract.context string defining cytosine methylation context used report: \"CG\" (default) – CpG cytosines (called zZ) \"CHG\" – CHG cytosines (xX) \"CHH\" – CHH cytosines (hH) \"CxG\" – CG CHG cytosines (zZxX) \"CX\" – cytosines min.context.freq real number range [0;1] (default: 0.01). Genomic positions covered smaller fraction patterns (e.g., erroneous context) included report. clip.patterns boolean patterns extend edge `bed` region (default: FALSE). strand.offset single non-negative integer specifying offset bases reverse (-) strand compared forward (+) strand. Allows \"merge\" genomic positions methylation symmetric (CG CHG contexts). default, equals 1 `extract.context`==\"CG\", 2 \"CHG\", 0 otherwise. highlight.positions integer vector genomic positions bases include every overlapping pattern. Allows visualize distribution single-nucleotide variations (SNVs) among methylation patterns. `highlight.positions` takes precedence positions overlap within--context positions methylation pattern. ... parameters pass preprocessBam function. Options effect preprocessed BAM data supplied input. verbose boolean report progress timings (default: TRUE).","code":""},{"path":"/reference/extractPatterns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"extractPatterns — extractPatterns","text":"data.table object containing per-read (pair) base methylation information genomic region interest. report columns : seqnames – read (pair) reference sequence name strand – read (pair) strand start – start read (pair) end – end read (pair) nbase – number within--context bases read (pair) beta – beta value read (pair), calculated ratio   number methylated within--context bases total number   within--context bases pattern – hex representation 64-bit FNV-1a hash calculated   reported base positions bases read (pair).   hash value depends included genomic positions methylation   call string chars (hHxXzZ) nucleotides (ACGT, highlighted bases   ), thus expected unique every   methylation pattern, although equal identical methylation patterns   independently read (pair) start, end, strand (correct   `strand.offset` given) ... – columns genomic position hold corresponding   methylation call string char, NA position present read   (pair)","code":""},{"path":"/reference/extractPatterns.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"extractPatterns — extractPatterns","text":"function matches reads (paired-end sequencing alignment files - read pairs single entity) genomic region provided BED file/GRanges object, extracts methylation statuses bases within reads, returns data frame can used analysis /plotting DNA methylation patterns plotPatterns function.","code":""},{"path":[]},{"path":"/reference/extractPatterns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"extractPatterns — extractPatterns","text":"","code":"# amplicon data   amplicon.bam <- system.file(\"extdata\", \"amplicon010meth.bam\",                               package=\"epialleleR\")   amplicon.bed <- system.file(\"extdata\", \"amplicon.bed\",                               package=\"epialleleR\")      # extract patterns   patterns <- extractPatterns(bam=amplicon.bam, bed=amplicon.bed, bed.row=3) #> Reading BED file  #> [0.033s] #> Checking BAM file:  #> short-read, paired-end, name-sorted alignment detected #> Reading paired-end BAM file  #> [0.010s] #> Extracting methylation patterns  #> [0.026s]      # and then plot them   plotPatterns(patterns) #> 238 patterns supplied #> 45 unique #> 9 most frequent unique patterns were selected for plotting using 10 beta value bins: #> [0,0.1) [0.1,0.2) [0.2,0.3) [0.3,0.4) [0.4,0.5) [0.5,0.6) [0.6,0.7) [0.7,0.8) [0.8,0.9) [0.9,1] #>       2         1         1         0         0         0         0         1         2       2"},{"path":"/reference/generateBedEcdf.html","id":null,"dir":"Reference","previous_headings":"","what":"generateBedEcdf — generateBedEcdf","title":"generateBedEcdf — generateBedEcdf","text":"function computes empirical cumulative distribution functions (eCDF) per-read beta values sequencing reads.","code":""},{"path":"/reference/generateBedEcdf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"generateBedEcdf — generateBedEcdf","text":"","code":"generateBedEcdf(   bam,   bed,   bed.type = c(\"amplicon\", \"capture\"),   bed.rows = c(1),   zero.based.bed = FALSE,   match.tolerance = 1,   match.min.overlap = 1,   ecdf.context = c(\"CG\", \"CHG\", \"CHH\", \"CxG\", \"CX\"),   ...,   verbose = TRUE )"},{"path":"/reference/generateBedEcdf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"generateBedEcdf — generateBedEcdf","text":"bam BAM file location string preprocessed output preprocessBam function. Read BAM file requirements BAM preprocessing preprocessBam. bed Browser Extensible Data (BED) file location string object class GRanges holding genomic coordinates regions interest. used match sequencing reads genomic regions prior eCDF computation. style seqlevels BED file/object must match style seqlevels BAM file/object used. bed.type character string type assay used produce sequencing reads: \"amplicon\" (default) – used amplicon-based next-generation   sequencing exact coordinates sequenced fragments known.   Matching reads genomic ranges performed read's start   end positions, either   `match.tolerance` bases away start end position genomic   ranges given BED file/GRanges object \"capture\" – used capture-based next-generation sequencing   reads partially overlap capture target regions. Read considered   match genomic range overlap equal   `match.min.overlap`. read matches two BED genomic regions,   first match taken (input GRanges   sorted internally) bed.rows integer vector specifying `bed` regions included output. `c(1)` (default), function returns eCDFs first region `bed`, NULL - eCDF functions `bed` genomic regions well reads match regions (last element return value; reads). zero.based.bed boolean defining BED coordinates zero based (default: FALSE). match.tolerance integer largest difference read's BED GRanges start end positions matching amplicon-based NGS reads (default: 1). match.min.overlap integer smallest overlap read's BED GRanges start end positions matching capture-based NGS reads (default: 1). read matches two BED genomic regions, first match taken (input GRanges sorted internally). ecdf.context string defining cytosine methylation context used computing within--context --context eCDFs: \"CG\" (default) – within--context: CpG cytosines (called   zZ), --context: cytosines (hHxX) \"CHG\" – within--context: CHG cytosines (xX), --context: hHzZ \"CHH\" – within--context: CHH cytosines (hH), --context: xXzZ \"CxG\" – within--context: CG CHG cytosines (zZxX),   --context: CHH cytosines (hH) \"CX\" – cytosines considered within--context ... parameters pass preprocessBam function. Options effect preprocessed BAM data supplied input. verbose boolean report progress timings (default: TRUE).","code":""},{"path":"/reference/generateBedEcdf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"generateBedEcdf — generateBedEcdf","text":"list number elements equal length `bed.rows` (NULL), number genomic regions within `bed` (`bed.rows==NULL`) plus one item reads matching `bed` genomic regions (). Every list item list , consisting two eCDF functions within- --context per-read beta values.","code":""},{"path":"/reference/generateBedEcdf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"generateBedEcdf — generateBedEcdf","text":"function matches reads (paired-end sequencing alignment files - read pairs single entity) genomic regions provided BED file/GRanges object, computes average per-read beta values according cytosine context parameter `ecdf.context`, returns list eCDFs within- --context average per-read beta values, can used plotting. resulting eCDFs plots can used characterise methylation pattern particular genomic region, e.g. reads match region methylated \"-CpGs--none\" manner intermediate methylation levels frequent.","code":""},{"path":[]},{"path":"/reference/generateBedEcdf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"generateBedEcdf — generateBedEcdf","text":"","code":"# amplicon data   amplicon.bam <- system.file(\"extdata\", \"amplicon010meth.bam\",                               package=\"epialleleR\")   amplicon.bed <- system.file(\"extdata\", \"amplicon.bed\",                               package=\"epialleleR\")      # let's compute eCDF   amplicon.ecdfs <- generateBedEcdf(bam=amplicon.bam, bed=amplicon.bed,                                     bed.rows=NULL) #> Reading BED file  #> [0.007s] #> Checking BAM file:  #> short-read, paired-end, name-sorted alignment detected #> Reading paired-end BAM file  #> [0.005s] #> Computing ECDFs for within- and out-of-context per-read beta values  #> [0.042s]      # there are 5 items in amplicon.ecdfs, let's plot them all   par(mfrow=c(1,length(amplicon.ecdfs)))      # cycle through items   for (x in 1:length(amplicon.ecdfs)) {     # four of them have names corresponding to amplicon.bed genomic regions,      # fifth - NA for all the reads that don't match to any of those regions     main <- if (is.na(names(amplicon.ecdfs[x]))) \"unmatched\"             else names(amplicon.ecdfs[x])          # plotting eCDF for within-the-context per-read beta values (in red)     plot(amplicon.ecdfs[[x]]$context, col=\"red\", verticals=TRUE,          do.points=FALSE, xlim=c(0,1), xlab=\"per-read beta value\",          ylab=\"cumulative density\", main=main)          # adding eCDF for out-of-context per-read beta values (in blue)     plot(amplicon.ecdfs[[x]]$out.of.context, add=TRUE, col=\"blue\",          verticals=TRUE, do.points=FALSE)   }       # recover default plotting parameters   par(mfrow=c(1,1))"},{"path":"/reference/generateBedReport.html","id":null,"dir":"Reference","previous_headings":"","what":"generateBedReport — generateBedReport","title":"generateBedReport — generateBedReport","text":"`generateBedReport`, `generateAmpliconReport`, `generateCaptureReport` – functions match BAM reads set genomic locations return fraction reads average methylation level passing arbitrary threshold.","code":""},{"path":"/reference/generateBedReport.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"generateBedReport — generateBedReport","text":"","code":"generateAmpliconReport(   bam,   bed,   report.file = NULL,   zero.based.bed = FALSE,   match.tolerance = 1,   threshold.reads = TRUE,   threshold.context = c(\"CG\", \"CHG\", \"CHH\", \"CxG\", \"CX\"),   min.context.sites = 2,   min.context.beta = 0.5,   max.outofcontext.beta = 0.1,   ...,   gzip = FALSE,   verbose = TRUE )  generateCaptureReport(   bam,   bed,   report.file = NULL,   zero.based.bed = FALSE,   match.min.overlap = 1,   threshold.reads = TRUE,   threshold.context = c(\"CG\", \"CHG\", \"CHH\", \"CxG\", \"CX\"),   min.context.sites = 2,   min.context.beta = 0.5,   max.outofcontext.beta = 0.1,   ...,   gzip = FALSE,   verbose = TRUE )  generateBedReport(   bam,   bed,   report.file = NULL,   zero.based.bed = FALSE,   bed.type = c(\"amplicon\", \"capture\"),   match.tolerance = 1,   match.min.overlap = 1,   threshold.reads = TRUE,   threshold.context = c(\"CG\", \"CHG\", \"CHH\", \"CxG\", \"CX\"),   min.context.sites = 2,   min.context.beta = 0.5,   max.outofcontext.beta = 0.1,   ...,   gzip = FALSE,   verbose = TRUE )"},{"path":"/reference/generateBedReport.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"generateBedReport — generateBedReport","text":"bam BAM file location string preprocessed output preprocessBam function. Read BAM file requirements BAM preprocessing preprocessBam. bed Browser Extensible Data (BED) file location string object class GRanges holding genomic coordinates regions interest. style seqlevels BED file/object must style seqlevels BAM file/object used. BED/GRanges rows sorted internally. now, strand information ignored reads (read pairs) matching strands separately counted reported. report.file file location string write BED report. NULL (default) report returned data.table object. zero.based.bed boolean defining BED coordinates zero based (default: FALSE). match.tolerance integer largest difference read's BED GRanges start end positions matching amplicon-based NGS reads (default: 1). threshold.reads boolean defining sequence reads thresholded counting reads belonging variant epialleles (default: TRUE). Disabling thresholding possible makes sense context function, reads assigned variant epiallele, result VEF==1 (case `NA` VEF values returned order avoid confusion). thresholding recommended long-read sequencing data, function recommended data either. threshold.context string defining cytosine methylation context used thresholding reads: \"CG\" (default) – within--context: CpG cytosines (called   zZ), --context: cytosines (hHxX) \"CHG\" – within--context: CHG cytosines (xX), --context: hHzZ \"CHH\" – within--context: CHH cytosines (hH), --context: xXzZ \"CxG\" – within--context: CG CHG cytosines (zZxX),   --context: CHH cytosines (hH) \"CX\" – cytosines considered within--context,   effectively results thresholding option effect read thresholding disabled. min.context.sites non-negative integer minimum number cytosines within `threshold.context` (default: 2). Reads containing fewer within--context cytosines considered completely unmethylated (thus belonging reference epiallele). option effect read thresholding disabled. min.context.beta real number range [0;1] (default: 0.5). Reads average beta value within--context cytosines threshold considered completely unmethylated (thus belonging reference epiallele). option effect read thresholding disabled. max.outofcontext.beta real number range [0;1] (default: 0.1). Reads average beta value --context cytosines threshold considered completely unmethylated (thus belonging reference epiallele). option effect read thresholding disabled. ... parameters pass preprocessBam function. Options effect preprocessed BAM data supplied input. gzip boolean compress report (default: FALSE). verbose boolean report progress timings (default: TRUE). match.min.overlap integer smallest overlap read's BED GRanges start end positions matching capture-based NGS reads (default: 1). read matches two BED genomic regions, first match taken (input GRanges sorted internally). bed.type character string type assay used produce sequencing reads: \"amplicon\" (default) – used amplicon-based next-generation   sequencing exact coordinates sequenced fragments known.   Matching reads genomic ranges performed read's start   end positions, either   `match.tolerance` bases away start end position genomic   ranges given BED file/GRanges object \"capture\" – used capture-based next-generation sequencing   reads partially overlap capture target regions. Read considered   match genomic range overlap equal   `match.min.overlap`. read matches two BED genomic regions,   first match taken (input GRanges   sorted internally)","code":""},{"path":"/reference/generateBedReport.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"generateBedReport — generateBedReport","text":"data.table object containing VEF report BED GRanges NULL report.file specified. BAM file contains reads match BED GRanges, last row report contain information reads (seqnames, start end equal NA). report columns : seqnames – reference sequence name start – start genomic region end – end genomic region width – width genomic region strand – strand ... – columns present BED metadata columns   GRanges object nreads+ – number reads (pairs) mapped forward (\"+\") strand nreads- – number reads (pairs) mapped reverse (\"-\") strand VEF – frequency reads passing threshold","code":""},{"path":"/reference/generateBedReport.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"generateBedReport — generateBedReport","text":"Functions report hypermethylated variant epiallele frequencies (VEF) per genomic region interest using BAM BED files input. Reads (paired-end sequencing alignment files - read pairs single entity) matched genomic locations exact coordinates (`generateAmpliconReport` `generateBedReport` option bed.type=\"amplicon\") minimum overlap (`generateCaptureReport` `generateBedReport` option bed.type=\"capture\") – former used amplicon-based NGS data, latter – capture-based NGS data. function's logic explained . suppose BAM file four reads, mapped \"+\" strand chromosome 1, positions 1-16. genomic range supplied parameter `bed = (\"chr1:1-100\", \"GRanges\")`. Assuming default values thresholding parameters (threshold.reads = TRUE, threshold.context = \"CG\", min.context.sites = 2, min.context.beta = 0.5, max.outofcontext.beta = 0.1), input results look following: second read satisfy thresholding criteria, leading following BED report (given reads map chr1:+:1-16): Please note, read thresholding average methylation level (explained ) makes little sense long-read sequencing alignments, reads can cover multiple regions different DNA methylation properties. Instead, please use extractPatterns, limiting pattern output region interest .","code":""},{"path":[]},{"path":"/reference/generateBedReport.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"generateBedReport — generateBedReport","text":"","code":"# amplicon data   amplicon.bam    <- system.file(\"extdata\", \"amplicon010meth.bam\",                                  package=\"epialleleR\")   amplicon.bed    <- system.file(\"extdata\", \"amplicon.bed\",                                  package=\"epialleleR\")   amplicon.report <- generateAmpliconReport(bam=amplicon.bam,                                             bed=amplicon.bed) #> Reading BED file  #> [0.007s] #> Checking BAM file:  #> short-read, paired-end, name-sorted alignment detected #> Reading paired-end BAM file  #> [0.004s] #> Thresholding reads  #> [0.001s] #> Preparing amplicon report  #> [0.012s]      # capture NGS   capture.bam    <- system.file(\"extdata\", \"capture.bam\",                                 package=\"epialleleR\")   capture.bed    <- system.file(\"extdata\", \"capture.bed\",                                 package=\"epialleleR\")   capture.report <- generateCaptureReport(bam=capture.bam, bed=capture.bed) #> Reading BED file  #> [0.008s] #> Checking BAM file:  #> short-read, paired-end, name-sorted alignment detected #> Reading paired-end BAM file  #> [0.013s] #> Thresholding reads  #> [0.001s] #> Preparing capture report  #> [0.022s]      # generateAmpliconReport and generateCaptureReport are just aliases   # of the generateBedReport   bed.report <- generateBedReport(bam=capture.bam, bed=capture.bed,                                   bed.type=\"capture\") #> Reading BED file  #> [0.007s] #> Checking BAM file:  #> short-read, paired-end, name-sorted alignment detected #> Reading paired-end BAM file  #> [0.014s] #> Thresholding reads  #> [0.001s] #> Preparing capture report  #> [0.015s]   identical(capture.report, bed.report) #> [1] TRUE"},{"path":"/reference/generateCytosineReport.html","id":null,"dir":"Reference","previous_headings":"","what":"generateCytosineReport — generateCytosineReport","title":"generateCytosineReport — generateCytosineReport","text":"function counts methylated unmethylated DNA bases taking account average methylation level entire sequence read.","code":""},{"path":"/reference/generateCytosineReport.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"generateCytosineReport — generateCytosineReport","text":"","code":"generateCytosineReport(   bam,   report.file = NULL,   threshold.reads = TRUE,   threshold.context = c(\"CG\", \"CHG\", \"CHH\", \"CxG\", \"CX\"),   min.context.sites = 2,   min.context.beta = 0.5,   max.outofcontext.beta = 0.1,   report.context = threshold.context,   ...,   gzip = FALSE,   verbose = TRUE )"},{"path":"/reference/generateCytosineReport.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"generateCytosineReport — generateCytosineReport","text":"bam BAM file location string preprocessed output preprocessBam function. Read BAM file requirements BAM preprocessing preprocessBam. report.file file location string write cytosine report. NULL (default) report returned data.table object. threshold.reads boolean defining sequence reads (read pairs) thresholded counting methylated cytosines (default: TRUE). Disabling thresholding makes report virtually indistinguishable ones generated software, Bismark Illumina DRAGEN Bio Platform. Thresholding recommended long-read sequencing data. threshold.context string defining cytosine methylation context used thresholding reads: \"CG\" (default) — within--context: CpG cytosines (called   zZ), --context: cytosines (hHxX) \"CHG\" — within--context: CHG cytosines (xX), --context: hHzZ \"CHH\" — within--context: CHH cytosines (hH), --context: xXzZ \"CxG\" — within--context: CG CHG cytosines (zZxX),   --context: CHH cytosines (hH) \"CX\" — cytosines considered within--context,   effectively results thresholding option effect read thresholding disabled. min.context.sites non-negative integer minimum number cytosines within `threshold.context` (default: 2). Reads containing fewer within--context cytosines considered completely unmethylated (C counted T). option effect read thresholding disabled. min.context.beta real number range [0;1] (default: 0.5). Reads average beta value within--context cytosines threshold considered completely unmethylated (C counted T). option effect read thresholding disabled. max.outofcontext.beta real number range [0;1] (default: 0.1). Reads average beta value --context cytosines threshold considered completely unmethylated (C counted T). option effect read thresholding disabled. report.context string defining cytosine methylation context report (default: value `threshold.context`). ... parameters pass preprocessBam function. Options effect preprocessed BAM data supplied input. gzip boolean compress report (default: FALSE). verbose boolean report progress timings (default: TRUE).","code":""},{"path":"/reference/generateCytosineReport.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"generateCytosineReport — generateCytosineReport","text":"data.table object containing cytosine report Bismark-like format NULL report.file specified. report columns : rname — reference sequence name (BAM) strand — strand pos — cytosine position context — methylation context meth — number methylated cytosines unmeth — number unmethylated cytosines","code":""},{"path":"/reference/generateCytosineReport.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"generateCytosineReport — generateCytosineReport","text":"function reports cytosine methylation information using BAM file data input. contrast currently available software, reads (paired-end sequencing alignment files - read pairs single entity) can thresholded average methylation level counting methylated bases, effectively resulting hypermethylated variant epiallele frequency (VEF) reported instead beta value. function's logic explained . suppose BAM file four reads, mapped \"+\" strand chromosome 1, positions 1-16. Assuming default values thresholding parameters (threshold.reads = TRUE, threshold.context = \"CG\", min.context.sites = 2, min.context.beta = 0.5, max.outofcontext.beta = 0.1), input results look following: second read satisfy thresholding criteria, leading following CX report (given reads map chr1:+:1-16): thresholding disabled (threshold.reads = FALSE) methylated bases retain status, CX report similar reports produced methylation callers (Bismark Illumina DRAGEN Bio Platform): notes: produce conventional cytosine reports without thresholding within-context methylation level though minimally affected incomplete cytosine conversion, run method following parameters: `threshold.reads=TRUE`, `threshold.context=\"CG\"`, `min.context.sites=0`, `min.context.beta=0`, `max.outofcontext.beta=0.1`. cytosines within reads (read pairs) 10 cytosines methylated, effectively treated unmethylated ones. Methylation string bases unknown context (\"uU\") simply ignored, , best knowledge, consistent behaviour tools. order mitigate effect sequencing errors (leading rare variations methylation context, reads 1 4 ), context present 50% reads assumed correct, bases position methylation context simply ignored. allows reports prepared without using reference genome sequence. downside using reference genome sequence inability determine actual sequence triplet every base cytosine report. Therefore sequence reported, change information considered worth adding. Please also note, read thresholding average methylation level (explained ) makes little sense long-read sequencing alignments, reads can cover multiple regions different DNA methylation properties.","code":""},{"path":[]},{"path":"/reference/generateCytosineReport.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"generateCytosineReport — generateCytosineReport","text":"","code":"capture.bam <- system.file(\"extdata\", \"capture.bam\", package=\"epialleleR\")      # CpG report with thresholding   cg.report <- generateCytosineReport(capture.bam) #> Checking BAM file:  #> short-read, paired-end, name-sorted alignment detected #> Reading paired-end BAM file  #> [0.012s] #> Thresholding reads  #> [0.001s] #> Preparing cytosine report  #> [0.013s]      # CX report without thresholding   cx.report <- generateCytosineReport(capture.bam, threshold.reads=FALSE,                report.context=\"CX\") #> Checking BAM file:  #> short-read, paired-end, name-sorted alignment detected #> Reading paired-end BAM file  #> [0.011s] #> Preparing cytosine report  #> [0.017s]"},{"path":"/reference/generateMhlReport.html","id":null,"dir":"Reference","previous_headings":"","what":"generateMhlReport — generateMhlReport","title":"generateMhlReport — generateMhlReport","text":"function computes Linearised Methylated Haplotype Load (\\(lMHL\\)) per genomic position.","code":""},{"path":"/reference/generateMhlReport.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"generateMhlReport — generateMhlReport","text":"","code":"generateMhlReport(   bam,   report.file = NULL,   haplotype.context = c(\"CG\", \"CHG\", \"CHH\", \"CxG\", \"CX\"),   max.haplotype.window = 0,   min.haplotype.length = 0,   max.outofcontext.beta = 0.1,   ...,   gzip = FALSE,   verbose = TRUE )"},{"path":"/reference/generateMhlReport.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"generateMhlReport — generateMhlReport","text":"bam BAM file location string preprocessed output preprocessBam function. Read BAM file requirements BAM preprocessing preprocessBam. report.file file location string write \\(lMHL\\) report. NULL (default) report returned data.table object. haplotype.context string cytosine context defines haplotype: \"CG\" (default) – CpG cytosines (called zZ) \"CHG\" – CHG cytosines (xX) \"CHH\" – CHH cytosines (hH) \"CxG\" – CG CHG cytosines (zZxX) \"CX\" – cytosines; , well non-CG contexts,   may little sense still included consistency \\(lMHL\\) calculations needed three possible cytosine contexts independently, one run function required `haplotype.context` separately, `haplotype.context`==\"CX\" assumes cytosine context allowed within haplotype. behaviour may change future. max.haplotype.window non-negative integer maximum value \\(L'\\) \\(lMHL\\) formula. 0 (default), calculations performed full haplotype length (\\(L'=L\\), although maximum value currently limited 65535). length restrictions make sense short-read sequencing length read comparable length typical methylated block, depth coverage high, lengths reads roughly equal. However, calculations using non-restricted haplotype length meaningless long-read sequencing — read may cover number regions different methylation properties, reads can different length. latter case advised limit `max.haplotype.window` number cytosines typical hypermethylated region. thorough explanation examples, see Details section vignette. min.haplotype.length non-negative integer minimum length haplotype (default: 0 include haplotypes length). `min.haplotype.length`>0, reads (read pairs) fewer `min.haplotype.length` cytosines within `haplotype.context` skipped. max.outofcontext.beta real number range [0;1] (default: 0.1). Reads (read pairs) average beta value --context cytosines threshold skipped. Set 1 disable filtering. ... parameters pass preprocessBam function. Options effect preprocessed BAM data supplied input. gzip boolean compress report (default: FALSE). verbose boolean report progress timings (default: TRUE).","code":""},{"path":"/reference/generateMhlReport.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"generateMhlReport — generateMhlReport","text":"data.table object containing \\(lMHL\\) report NULL report.file specified. report columns : rname – reference sequence name (BAM) strand – strand pos – cytosine position context – methylation context coverage – number reads (read pairs) include position length – average length haplotype, .e.,   average number cytosines within `haplotype.context`   reads (read pairs) include position lmhl – \\(lMHL\\) value","code":""},{"path":"/reference/generateMhlReport.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"generateMhlReport — generateMhlReport","text":"function reports Linearised Methylated Haplotype Load (\\(lMHL\\)) level individual cytosines using BAM file location preprocessed data input. Function uses following formula: $$lMHL=\\frac{\\sum_{=1}^{L'} w_{} \\times MH_{}}{\\sum_{=1}^{L'} w_{} \\times H_{}}$$ \\(L'\\) length calculation window (e.g., number CpGs; \\(L' \\le L\\), \\(L\\) length haplotype covering current genomic position), \\(MH_{}\\) number fully successive methylated stretches \\(\\) loci within methylated stretch overlaps current genomic position, \\(H_{}\\) number fully successive stretches \\(\\) loci, \\(w_{}\\) weight \\(\\)-locus haplotype (\\(w_{}=\\)). formula modification original Methylated Haplotype Load (MHL) formula first described Guo et al., 2017 (doi: 10.1038/ng.3805): $$MHL=\\frac{\\sum_{=1}^{L} w_{} \\times \\frac{MH_{}}{H_{}}}{\\sum_{=1}^{L} w_{}}$$ \\(L\\) length longest haplotype covering current genomic position, \\(\\frac{MH_{}}{H_{}}=P(MH_{})\\) fraction fully successive methylated stretches \\(\\) loci, \\(w_{}\\) weight \\(\\)-locus haplotype (\\(w_{}=\\)). modifications original formula made order : provide granularity values — original MHL   formula gives MHL value every cytosine partially   methylated haplotype (e.g., MHL=0.358 cytosine within read   methylation call string \"zZZZ\"). contrast, \\(lMHL\\)==0   non-methylated cytosines (e.g., \\(lMHL\\)==c(0, 0.5, 0.5, 0.5)   cytosines within read methylation call string \"zZZZ\"). enable calculations long-read sequencing alignments —   \\(lMHL\\)   calculation window can limited particular number cytosines.   allows use formula long haplotypes well   compare values sequencing data varying read length. reduce complexity MHL calculation data high   breadth depth — \\(lMHL\\) values genomic positions can   calculated using single pass (cycling reads just )   linearised calculations numerator denominator   \\(lMHL\\) require prior knowledge many reads cover   particular position. achieved moving \\(H_{}\\) multiplier   denominator \\(lMHL\\) formula. modifications make \\(lMHL\\) calculation similar though non-equivalent original MHL. However, important property MHL — emphasis hypermethylated blocks — retained. return, \\(lMHL\\) gets better applicability analysis sequencing data varying depth read length. notes function's behaviour: Methylation string bases unknown context (\"uU\") simply ignored, , best knowledge, consistent behaviour tools. Cytosine context present 50% reads assumed correct, bases position methylation context simply ignored. allows reports prepared without using reference genome sequence.","code":""},{"path":[]},{"path":"/reference/generateMhlReport.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"generateMhlReport — generateMhlReport","text":"","code":"capture.bam <- system.file(\"extdata\", \"capture.bam\", package=\"epialleleR\")      # lMHL report   mhl.report <- generateMhlReport(capture.bam) #> Checking BAM file:  #> short-read, paired-end, name-sorted alignment detected #> Reading paired-end BAM file  #> [0.012s] #> Preparing lMHL report  #> [0.021s]      # lMHL report with a `max.haplotype.window` of 1 is identical to a   # conventional cytosine report (or nearly identical when sequencing errors   # are present)   mhl.report <- generateMhlReport(capture.bam, max.haplotype.window=1) #> Checking BAM file:  #> short-read, paired-end, name-sorted alignment detected #> Reading paired-end BAM file  #> [0.012s] #> Preparing lMHL report  #> [0.023s]   cg.report  <- generateCytosineReport(capture.bam, threshold.reads=FALSE) #> Checking BAM file:  #> short-read, paired-end, name-sorted alignment detected #> Reading paired-end BAM file  #> [0.012s] #> Preparing cytosine report  #> [0.013s]   identical(     mhl.report[, .(rname, strand, pos, context, value=lmhl)],     cg.report[ , .(rname, strand, pos, context, value=meth/(meth+unmeth))]   ) #> [1] TRUE"},{"path":"/reference/generateVcfReport.html","id":null,"dir":"Reference","previous_headings":"","what":"generateVcfReport — generateVcfReport","title":"generateVcfReport — generateVcfReport","text":"function reports base frequencies particular genomic positions tests association methylation status sequencing reads.","code":""},{"path":"/reference/generateVcfReport.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"generateVcfReport — generateVcfReport","text":"","code":"generateVcfReport(   bam,   vcf,   vcf.style = NULL,   bed = NULL,   report.file = NULL,   zero.based.bed = FALSE,   threshold.reads = TRUE,   threshold.context = c(\"CG\", \"CHG\", \"CHH\", \"CxG\", \"CX\"),   min.context.sites = 2,   min.context.beta = 0.5,   max.outofcontext.beta = 0.1,   ...,   gzip = FALSE,   verbose = TRUE )"},{"path":"/reference/generateVcfReport.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"generateVcfReport — generateVcfReport","text":"bam BAM file location string preprocessed output preprocessBam function. Read BAM file requirements BAM preprocessing preprocessBam. vcf Variant Call Format (VCF) file location string VCF object returned readVcf function. VCF object supplied, style seqlevels must match style seqlevels BAM file/object used. vcf.style string seqlevels style VCF file, different BED file/object. effect `vcf` parameter points VCF file location `bed` NULL. Possible values: NULL (default) – seqlevels BED file/object VCF file   \"NCBI\", \"UCSC\", ... – valid parameters   seqlevelsStyle function bed Browser Extensible Data (BED) file location string object class GRanges holding genomic coordinates regions interest. used include specific genomic ranges VCF file loaded. option effect VCF object supplied `vcf` parameter. style seqlevels BED file/object must match style seqlevels BAM file/object used. report.file file location string write VCF report. NULL (default) report returned data.table object. zero.based.bed boolean defining BED coordinates zero based (default: FALSE). threshold.reads boolean defining sequence reads thresholded counting bases reference variant epialleles (default: TRUE). Disabling thresholding possible makes sense context function, reads assigned variant epiallele, result Fisher's Exact test p-value 1 (columns `FEp+` `FEP-`). thresholding recommended long-read sequencing data, function recommended data either. threshold.context string defining cytosine methylation context used thresholding reads: \"CG\" (default) – within--context: CpG cytosines (called   zZ), --context: cytosines (hHxX) \"CHG\" – within--context: CHG cytosines (xX), --context: hHzZ \"CHH\" – within--context: CHH cytosines (hH), --context: xXzZ \"CxG\" – within--context: CG CHG cytosines (zZxX),   --context: CHH cytosines (hH) \"CX\" – cytosines considered within--context,   effectively results thresholding option effect read thresholding disabled. min.context.sites non-negative integer minimum number cytosines within `threshold.context` (default: 2). Reads containing fewer within--context cytosines considered completely unmethylated (thus belonging reference epiallele). option effect read thresholding disabled. min.context.beta real number range [0;1] (default: 0.5). Reads average beta value within--context cytosines threshold considered completely unmethylated (thus belonging reference epiallele). option effect read thresholding disabled. max.outofcontext.beta real number range [0;1] (default: 0.1). Reads average beta value --context cytosines threshold considered completely unmethylated (thus belonging reference epiallele). option effect read thresholding disabled. ... parameters pass preprocessBam function. Options effect preprocessed BAM data supplied input. gzip boolean compress report (default: FALSE). verbose boolean report progress timings (default: TRUE).","code":""},{"path":"/reference/generateVcfReport.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"generateVcfReport — generateVcfReport","text":"data.table object containing VCF report NULL report.file specified. report columns : name – variation identifier (e.g. \"rs123456789\") seqnames – reference sequence name range – genomic coordinates variation REF – base reference allele ALT – base alternative allele [M|U][+|-][Ref|Alt] – number Reference   Alternative bases found particular position   within Methylated (threshold) Unmethylated   (threshold) reads mapped \"+\" (forward)   \"-\" (reverse) DNA strand. NA values mean   possible determine number bases due bisulfite   conversion-related limitations (C->T variants \"+\" G->\"-\"   strands) SumRef – sum Reference base counts SumAlt – sum Alternative base counts FEp+ – Fisher Exact test p-value association variation   methylation status reads map \"+\"   (forward) DNA strand. Calculated using following contingency table: FEp- – Fisher Exact test p-value association variation   methylation status reads map \"-\"   (reverse) DNA strand. Calculated using following contingency table:","code":""},{"path":"/reference/generateVcfReport.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"generateVcfReport — generateVcfReport","text":"Using BAM reads sequence variation information input, `generateVcfReport` function thresholds reads (paired-end sequencing alignment files - read pairs single entity) according supplied parameters calculates occurrence Reference Alternative bases within reads, taking account DNA strand read mapped average methylation level (epiallele status) read. information sequence variation can supplied Variant Call Format (VCF) file location object class VCF, returned readVcf function call. whole-genome VCF files can extremely large, strongly advised use relevant subset data, prefiltering VCF object manually calling `generateVcfReport` specifying `bed` parameter `vcf` points location large VCF file. Please note BAM, BED VCF files must use style seqlevels (.e. chromosome names). counting, function checks certain bases occur often within reads belonging certain epialleles using Fisher Exact test (HTSlib's implementation) reports separate p-values reads mapped \"+\" (forward) \"-\" (reverse) DNA strands. Please note final report currently includes VCF entries single-base REF ALT alleles. Also, default (`min.baseq=0`) output `generateVcfReport` equivalent one `samtools mplieup -Q 0 ...`, therefore may result false SNVs caused misalignments. Remember increase `min.baseq` (`samtools mplieup -Q` default value 13) obtain higher-quality results. Read thresholding average methylation level used function makes little sense long-read sequencing alignments, reads can cover multiple regions different DNA methylation properties. Instead, please use extractPatterns, limiting pattern output region interest .","code":""},{"path":[]},{"path":"/reference/generateVcfReport.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"generateVcfReport — generateVcfReport","text":"","code":"capture.bam <- system.file(\"extdata\", \"capture.bam\", package=\"epialleleR\")   capture.bed <- system.file(\"extdata\", \"capture.bed\", package=\"epialleleR\")   capture.vcf <- system.file(\"extdata\", \"capture.vcf.gz\",                              package=\"epialleleR\")      # VCF report   vcf.report <- generateVcfReport(bam=capture.bam, bed=capture.bed,                                   vcf=capture.vcf) #> Loading required namespace: VariantAnnotation #> Reading BED file  #> [0.026s] #> Reading VCF file  #> [4.735s] #> Checking BAM file:  #> short-read, paired-end, name-sorted alignment detected #> Reading paired-end BAM file  #> [0.012s] #> Thresholding reads  #> [0.001s] #> Extracting base frequences  #> [0.111s]"},{"path":"/reference/plotPatterns.html","id":null,"dir":"Reference","previous_headings":"","what":"plotPatterns — plotPatterns","title":"plotPatterns — plotPatterns","text":"convenience function plots methylation patterns (epialleles) previously extracted extractPatterns.","code":""},{"path":"/reference/plotPatterns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plotPatterns — plotPatterns","text":"","code":"plotPatterns(   patterns,   order.by = c(\"beta\", \"count\"),   beta.range = c(0, 1),   bin.context = c(\"CG\", \"CHG\", \"CHH\", \"CxG\", \"CX\"),   nbins = 10,   npatterns.per.bin = 2,   plot.context = c(\"CG\", \"CHG\", \"CHH\", \"CxG\", \"CX\"),   genomic.scale = c(\"continuous\", \"discrete\"),   breaks = \"auto\",   marginal = c(\"density\", \"count\"),   marginal.position = c(\"left\", \"right\"),   marginal.transform = c(\"identity\", \"log10\"),   marginal.limits = NULL,   marginal.size = 0.25,   ...,   tag = c(\"none\", \"count\", \"beta\", \"pattern\"),   tag.size = 2.5,   tag.colour = \"#87654c\",   tag.fill = \"lemonchiffon\",   title = TRUE,   subtitle = TRUE,   context.size = c(1, 2, 3),   base.size = 3,   methylation.fill = c(\"grey97\", \"grey10\"),   plot = TRUE,   verbose = TRUE )"},{"path":"/reference/plotPatterns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plotPatterns — plotPatterns","text":"patterns output preprocessBam function (methylation patterns data.table object). order.string defining order patterns plot (default order : \"beta\"). beta.range numeric vector length 2 range average pattern beta values represented plot (default: [0;1]). bin.context string defining cytosine methylation context used calculate average beta value pattern used assign patterns bins: \"CG\" (default) – CpG cytosines (called zZ) \"CHG\" – CHG cytosines (xX) \"CHH\" – CHH cytosines (hH) \"CxG\" – CG CHG cytosines (zZxX) \"CX\" – cytosines nbins single integer defining number bins (.e., intervals within `beta.range`). Default: 10. npatterns.per.bin integer vector number abundant patterns selected bin (default: 2). length 1, number patterns taken. length `nbins`, allows fine-tune number selected patterns bin. Setting `Inf` effectively results plotting patterns. plot.context string defining methylation context cytosines included plot (default: \"CG\"; range available values, see `bin.context` ). genomic.scale string type genomic position scale plot: either \"continuous\" (default) \"discrete\". breaks vector breaks genomic position scale plot. \"auto\" (default), breaks continuous scale computed default ggplot2 routines, breaks discrete scale subset plotted positions selected using pretty. Possible values: ggplot2::waiver() ggplot2 defaults, integer vector breaks continuous scale, character vector breaks discrete scale. marginal string type marginal plot: either \"density\" (probability density average beta values patterns; default) \"count\" (counts plotted patterns). \"none\" implemented yet; create issue interested. marginal.position string position marginal plot: either \"left\" (default) \"right\" (implemented yet; create issue interested). marginal.transform string transformation marginal scale (default: \"identity\"). Check ggplot2::scale_x_continuous() details. marginal.limits limits marginal scale (default: NULL). Check ggplot2::scale_x_continuous() details. marginal.size numeric range (0;1) relative width marginal plot (default: 0.25). ... additional arguments passed stats::density() call used marginal density plot. Possible value: adjust=0.25. tag string optional tagging patterns count (\"count\"), average beta value (\"beta\"), pattern ID (\"pattern\"). Default: \"none\". tag.size numeric font size tag text (millimetres; default: 2.5). tag.colour string colour tag text. Default: \"#87654c\". tag.fill string colour tag background. Default: \"lemonchiffon\". title title plot. `TRUE` (default), genomic region patterns extracted. possible values: anything can converted string, `NULL` title. subtitle subtitle plot. `TRUE` (default), number patterns plotted. possible values: anything can converted string, `NULL` subtitle. context.size numeric vector sizes circles representing cytosines within three contexts: CHH, CHG, CG (default: c(1, 2, 3)). base.size numeric font size text highlighted bases (millimetres; default: 3). methylation.fill vector length 2 colours representing unmethylated methylated cytosines, respectively. colours also mapped lowest (0) highest (1) possible beta values represent average beta values methylation patterns create gradient fill marginal density plot. Default: c(\"grey97\", \"grey10\"). plot boolean. `TRUE` (default), patterns plotted, selected ones silently returned data.table object. `FALSE`, grob table object returned instead. verbose boolean report basic info input output.","code":""},{"path":"/reference/plotPatterns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"plotPatterns — plotPatterns","text":"plot (silently) data.table object containing plotted methylation patterns (`plot==TRUE`), grob table object (`plot==FALSE`).","code":""},{"path":"/reference/plotPatterns.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"plotPatterns — plotPatterns","text":"number methylation patterns can quite large, default, function plots abundant unique patterns . complete logic follows: input methylation patterns, unique patterns   extracted counted unique patterns split bins average beta value abundant unique methylation patterns bin plotted   silently returned resulting plot, cytosine shown circle, size circle represents cytosine context fill encodes methylation status. available, highlighted bases shown labels different colours.","code":""},{"path":[]},{"path":"/reference/plotPatterns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"plotPatterns — plotPatterns","text":"","code":"# amplicon data   amplicon.bam <- system.file(\"extdata\", \"amplicon010meth.bam\",                               package=\"epialleleR\")   custom.range <- as(\"chr17:43124861-43125150\", \"GRanges\")      # let's get our patterns   patterns <- extractPatterns(bam=amplicon.bam, bed=custom.range) #> Checking BAM file:  #> short-read, paired-end, name-sorted alignment detected #> Reading paired-end BAM file  #> [0.004s] #> Extracting methylation patterns  #> [0.012s]      # default plot + silently returned plotted patterns   selected.patterns <- plotPatterns(patterns) #> 84 patterns supplied #> 21 unique #> 7 most frequent unique patterns were selected for plotting using 10 beta value bins: #> [0,0.1) [0.1,0.2) [0.2,0.3) [0.3,0.4) [0.4,0.5) [0.5,0.6) [0.6,0.7) [0.7,0.8) [0.8,0.9) [0.9,1] #>       2         1         1         0         0         0         0         1         0       2       # all unique patterns with their counts as a margin, categorical positions,   # tagged with pattern IDs, returned as a `gtable` object   tbl <- plotPatterns(patterns, npatterns.per.bin=Inf, marginal=\"count\",                       genomic.scale=\"discrete\", tag=\"pattern\", plot=FALSE) #> 84 patterns supplied #> 21 unique #> 21 most frequent unique patterns were selected for plotting using 10 beta value bins: #> [0,0.1) [0.1,0.2) [0.2,0.3) [0.3,0.4) [0.4,0.5) [0.5,0.6) [0.6,0.7) [0.7,0.8) [0.8,0.9) [0.9,1] #>      14         1         1         0         0         0         0         1         0       4      # which can be plotted later   grid::grid.newpage()   grid::grid.draw(tbl)"},{"path":"/reference/preprocessBam.html","id":null,"dir":"Reference","previous_headings":"","what":"preprocessBam — preprocessBam","title":"preprocessBam — preprocessBam","text":"function reads preprocesses BAM file.","code":""},{"path":"/reference/preprocessBam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"preprocessBam — preprocessBam","text":"","code":"preprocessBam(   bam.file,   paired = NULL,   min.mapq = 0,   min.baseq = 0,   min.prob = -1,   highest.prob = TRUE,   skip.duplicates = FALSE,   skip.secondary = TRUE,   skip.qcfail = TRUE,   skip.supplementary = TRUE,   trim = 0,   nthreads = 1,   verbose = TRUE )"},{"path":"/reference/preprocessBam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"preprocessBam — preprocessBam","text":"bam.file BAM file location string. paired boolean expected alignment endness: `TRUE` paired-end, `FALSE` single-end, `NULL` auto detect (default). min.mapq non-negative integer threshold minimum read mapping quality (default: 0). min.baseq non-negative integer threshold minimum nucleotide base quality (default: 0). min.prob integer threshold minimum scaled probability modification (methylation) consider. Affects processing long-read sequencing alignments . According SAM/BAM specification, continuous base modification probability range 0.0 1.0 remapped equal sized portions discrete integers 0 255 inclusively. default (-1), C+m G-m cytosine methylation modifications recorded MM/Mm tag included, even ML/Ml tag probabilities absent (case, probability modification equals -1). highest.prob boolean defining methylation modification must highest probability among modifications particular base considered analyses (default: TRUE). Affects processing long-read sequencing alignments . default (TRUE) ML/Ml tag probability scores absent, cytosines one modification omitted (probability modifications equal). skip.duplicates boolean defining duplicate aligned reads skipped (default: FALSE). Option effect duplicate reads marked alignment software. skip.secondary boolean defining secondary alignments skipped (default: TRUE). change. skip.qcfail boolean defining alignments failing QC skipped (default: TRUE). change. skip.supplementary boolean defining supplementary alignments skipped (default: TRUE). change. trim non-negative integer vector length 2 number nucleotide bases trimmed 5' 3' ends template (.e., read pair paired-end BAM read single-end BAM). Default: 0 trimming. Specifying `trim=1` result removing single base ends, specifying `trim=c(1,2)` result removing single base 5' end 2 bases 3' end. nthreads non-negative integer number additional HTSlib threads used BAM file decompression (default: 1). Two threads (usually two) make sense files larger 100 MB. verbose boolean report progress timings (default: TRUE).","code":""},{"path":"/reference/preprocessBam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"preprocessBam — preprocessBam","text":"data.table object containing preprocessed BAM data.","code":""},{"path":"/reference/preprocessBam.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"preprocessBam — preprocessBam","text":"function loads preprocesses BAM file, saving time multiple analyses performed large input files. Currently, HTSlib used read data, therefore possible speed loading means HTSlib decompression threads. function also called internally BAM file location supplied input `epialleleR` methods. `preprocessBam` currently allows load short-read (e.g., bisulfite) long-read (native) sequencing alignments. Specific requirements types data given .","code":""},{"path":"/reference/preprocessBam.html","id":"short-read-sequencing","dir":"Reference","previous_headings":"","what":"Short-read sequencing","title":"preprocessBam — preprocessBam","text":"preprocessing short reads (therefore reporting methods), `epialleleR` requires genomic strand (XG tag) methylation call string (XM tag) present BAM file - .e., methylation calling must performed read mapping/alignment software choice. case BAM files produced Bismark Bisulfite Read Mapper Methylation Caller, Illumina DRAGEN, Illumina Cloud analysis solutions, well contemporary Illumina sequencing instruments -board read mapping/alignment (NextSeq 1000/2000, NovaSeq X), therefore files can analysed without additional steps. alignments produced tools, e.g., BWA-meth BSMAP, methylation calling must performed prior BAM loading / reporting, means callMethylation.","code":""},{"path":"/reference/preprocessBam.html","id":"long-read-sequencing","dir":"Reference","previous_headings":"","what":"Long-read sequencing","title":"preprocessBam — preprocessBam","text":"preprocessing long reads, `epialleleR` requires presence MM (Mm) ML (Ml) tags hold information base modifications related probabilities, respectively. standard tags described SAM/BAM format specification, therefore relevant tools analysis alignment long sequencing reads able produce .","code":""},{"path":"/reference/preprocessBam.html","id":"other-details","dir":"Reference","previous_headings":"","what":"Other details","title":"preprocessBam — preprocessBam","text":"`preprocessBam` always tests BAM file paired- single-ended necessary tags available. recommended use `verbose` processing check messages correct identification alignment endness. Otherwise, `paired` parameter set explicitly, exception thrown expected endness differs auto detected one. preprocessing paired-end alignments, paired reads merged according base quality: nucleotide base highest value QUAL string taken, unless quality less `min.baseq`, results information particular position (\"-\"/\"N\"). merged reads processed single entity `epialleleR` methods. Due merging, overlapping bases read pairs counted , base highest quality taken. preprocessing single-end alignments, read merging performed. bases quality least `min.baseq` considered. Lower base quality results information particular position (\"-\"/\"N\"). RRBS-like protocols, possible trim alignments one ends. Trimming performed BAM loading therefore influence results downstream `epialleleR` methods. Internally, trimming performed level template (.e., read pair paired-end BAM individual read single-end BAM). ensures necessary parts (real ends sequenced fragment) removed paired-end sequencing reads. also requirement currently paired-end BAM file must sorted QNAME instead genomic location (.e., \"unsorted\") perform merging paired-end reads. Error message shown sorted genomic location, case please sort QNAME using 'samtools sort -n -o .bam .bam'.","code":""},{"path":"/reference/preprocessBam.html","id":"specific-considerations-for-long-read-sequencing-data","dir":"Reference","previous_headings":"","what":"Specific considerations for long-read sequencing data","title":"preprocessBam — preprocessBam","text":"location reported implicitly assumed contain modification. According SAM format specification, MM base modification tags allowed list modifications observed original sequenced strand (e.g., `C+m`) also opposite strand (e.g., `G-m`). logic processing follows (examples given ): alignment record methylation modifications (neither   `C+m`, `G-m` present), record , naturally, considered   single read cytosines methylated alignment record `C+m` modification (base modifications   original sequenced strand), record , naturally,   considered single read cytosine modifications   sequenced strand alignment record `G-m` modification (base modifications   strand opposite sequenced), record treated two   reads, original sequenced strand modifications,   opposite strand cytosine modifications `C+m` `G-m` present, record treated   two reads, strands cytosine modifications","code":""},{"path":[]},{"path":"/reference/preprocessBam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"preprocessBam — preprocessBam","text":"","code":"capture.bam <- system.file(\"extdata\", \"capture.bam\", package=\"epialleleR\")   bam.data    <- preprocessBam(capture.bam) #> Checking BAM file:  #> short-read, paired-end, name-sorted alignment detected #> Reading paired-end BAM file  #> [0.013s]      # Specifics of long-read alignment processing   out.bam <- tempfile(pattern=\"out-\", fileext=\".bam\")      simulateBam(     seq=c(\"ACGCCATYCGCGCCA\"),     Mm=c(\"C+m,0,2,0;\"),     Ml=list(as.integer(c(102,128,153))),     output.bam.file=out.bam   ) #> Writing sample BAM  #> [0.002s] #> [1] 1   generateCytosineReport(out.bam, threshold.reads=FALSE, report.context=\"CX\") #> Checking BAM file:  #> long-read, single-end, unsorted alignment detected #> Reading single-end BAM file  #> [0.001s] #> Preparing cytosine report  #> [0.000s] #>     rname strand   pos context  meth unmeth #>    <fctr> <fctr> <int>  <fctr> <int>  <int> #> 1:   chrS      +     2      CG     1      0 #> 2:   chrS      +     4     CHH     0      1 #> 3:   chrS      +     5     CHH     0      1 #> 4:   chrS      +     9      CG     1      0 #> 5:   chrS      +    11      CG     1      0 #> 6:   chrS      +    13     CHH     0      1 #> 7:   chrS      +    14     CHH     0      1      simulateBam(     seq=c(\"ACGCCATYCGCGCCA\"),     Mm=c(\"G-m,0,0,0;\"),     Ml=list(as.integer(c(138,101,96))),     output.bam.file=out.bam   ) #> Writing sample BAM  #> [0.001s] #> [1] 1   generateCytosineReport(out.bam, threshold.reads=FALSE, report.context=\"CX\") #> Checking BAM file:  #> long-read, single-end, unsorted alignment detected #> Reading single-end BAM file  #> [0.001s] #> Preparing cytosine report  #> [0.000s] #>      rname strand   pos context  meth unmeth #>     <fctr> <fctr> <int>  <fctr> <int>  <int> #>  1:   chrS      +     2      CG     0      1 #>  2:   chrS      -     3      CG     1      0 #>  3:   chrS      +     4     CHH     0      1 #>  4:   chrS      +     5     CHH     0      1 #>  5:   chrS      +     9      CG     0      1 #>  6:   chrS      -    10      CG     1      0 #>  7:   chrS      +    11      CG     0      1 #>  8:   chrS      -    12      CG     1      0 #>  9:   chrS      +    13     CHH     0      1 #> 10:   chrS      +    14     CHH     0      1      simulateBam(     seq=c(\"ACGCCATYCGCGCCA\"),     Mm=c(\"C+m,0,2,0;G-m,0,0,0;\"),     Ml=list(as.integer(c(102,128,153,138,101,96))),     output.bam.file=out.bam   ) #> Writing sample BAM  #> [0.002s] #> [1] 1   generateCytosineReport(out.bam, threshold.reads=FALSE, report.context=\"CX\") #> Checking BAM file:  #> long-read, single-end, unsorted alignment detected #> Reading single-end BAM file  #> [0.001s] #> Preparing cytosine report  #> [0.001s] #>      rname strand   pos context  meth unmeth #>     <fctr> <fctr> <int>  <fctr> <int>  <int> #>  1:   chrS      +     2      CG     1      0 #>  2:   chrS      -     3      CG     1      0 #>  3:   chrS      +     4     CHH     0      1 #>  4:   chrS      +     5     CHH     0      1 #>  5:   chrS      +     9      CG     1      0 #>  6:   chrS      -    10      CG     1      0 #>  7:   chrS      +    11      CG     1      0 #>  8:   chrS      -    12      CG     1      0 #>  9:   chrS      +    13     CHH     0      1 #> 10:   chrS      +    14     CHH     0      1"},{"path":"/reference/preprocessGenome.html","id":null,"dir":"Reference","previous_headings":"","what":"preprocessGenome — preprocessGenome","title":"preprocessGenome — preprocessGenome","text":"function reads preprocesses (optionally `bgzip`ped) FASTA file reference sequences.","code":""},{"path":"/reference/preprocessGenome.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"preprocessGenome — preprocessGenome","text":"","code":"preprocessGenome(genome.file, nthreads = 1, verbose = TRUE)"},{"path":"/reference/preprocessGenome.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"preprocessGenome — preprocessGenome","text":"genome.file reference (genomic) sequences file location string. nthreads non-negative integer number additional HTSlib threads used file decompression (default: 1). verbose boolean report progress timings (default: TRUE).","code":""},{"path":"/reference/preprocessGenome.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"preprocessGenome — preprocessGenome","text":"list object containing preprocessed reference sequence data.","code":""},{"path":"/reference/preprocessGenome.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"preprocessGenome — preprocessGenome","text":"function loads preprocesses reference (genomic) sequences, saving time methylation calling needs performed multiple BAM files. Currently, reading data done means HTSlib, therefore possible speed loading means HTSlib decompression threads FASTA file compressed `bgzip`. function also called internally file location supplied input callMethylation method. `preprocessGenome` checks index file present, , creates automatically. possible recommended use compressed FASTA file input, file must compressed `bgzip` (part samtools/HTSlib). FASTA file compressed, faster loading can achieved using (typically one) additional HTSlib decompression thread. loading, lowercase uppercase ACGTN symbols allowed correctly recognised, however symbols (e.g., extended IUPAC symbols, MRSVWYHKDB) within sequences converted N. Please also note purpose methylation calling, reference genome must used alignment (BAM produced) calling cytosine methylation callMethylation method.","code":""},{"path":[]},{"path":"/reference/preprocessGenome.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"preprocessGenome — preprocessGenome","text":"","code":"genome.file <- system.file(\"extdata\", \"test\", \"reference.fasta.gz\", package=\"epialleleR\")   genome.data <- preprocessGenome(genome.file) #> Reading reference genome file  #> [0.000s]"},{"path":"/reference/simulateBam.html","id":null,"dir":"Reference","previous_headings":"","what":"simulateBam — simulateBam","title":"simulateBam — simulateBam","text":"function creates sample BAM files given mandatory optional BAM fields.","code":""},{"path":"/reference/simulateBam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"simulateBam — simulateBam","text":"","code":"simulateBam(   output.bam.file = NULL,   qname = NULL,   flag = NULL,   rname = NULL,   pos = NULL,   mapq = NULL,   cigar = NULL,   rnext = NULL,   pnext = NULL,   tlen = NULL,   seq = NULL,   qual = NULL,   ...,   verbose = TRUE )"},{"path":"/reference/simulateBam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"simulateBam — simulateBam","text":"output.bam.file output BAM file location string. NULL (default), records written BAM returned data.table object review. qname character vector query names. default (NULL), names like \"q0001\"..\"qNNNN\" assigned. flag integer vector bitwise flags (combination BAM_F* constants). default (NULL), zero (.e., unique, valid, single-end, aligned read) assigned every record. rname character vector chromosome (reference) names. default (NULL), \"chrS\" assigned every record. pos integer vector 1-based leftmost coordinates queries. default (NULL), 1 assigned every record. mapq integer vector mapping qualities. default (NULL), 60 assigned every record. cigar character vector CIGAR strings. default (NULL), \"lM\" assigned every record, `l` length query (`seq`). rnext character vector chromosome (reference) names next read template. default (NULL), \"chrS\" assigned every record. pnext integer vector 1-based leftmost coordinates next read template. default (NULL), 1 assigned every record. tlen integer vector observed template lengths. default (NULL), length corresponding query (`seq`) assigned every record. seq character vector query sequences. default (NULL), random sequence assigned. lengths random sequences equal lengths methylation call strings `XM` optional parameter (supplied), `tlen` parameter (defined). none parameters supplied, length every `seq` equal 10. qual query sequence quality strings (ASCII base QUALity plus 33). default (NULL), quality every base assigned \"F\" (QUALity 47 + 33). lengths quality strings equal length corresponding query sequences (`seq`) every record. ... optional tags add records, form `tag=value`. Value can either: integer vector create tag single integer value per   alignment record (e.g., \"NM\" tag), float vector create tag single float value per   alignment record, character vector (e.g., \"XM\" tag methylation call string,   \"XG\"/\"YD\"/\"ZS\" tag reference strand read aligned ) list numeric vectors create tags array holding arrays   numeric values. verbose boolean report progress timings (default: TRUE).","code":""},{"path":"/reference/simulateBam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"simulateBam — simulateBam","text":"number BAM records written (`output.bam.file` NULL) data.table object containing final records prepared writing. NB: object 0-based coordinates numerically encoded reference names.","code":""},{"path":"/reference/simulateBam.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"simulateBam — simulateBam","text":"function creates sample alignment records saves BAM file. Output can used test epialleleR methods well tools methylation analysis. method can significantly simplify calculation methylation metrics example data (beta, VEF, lMHL values epialleleR; methylation heterogeneity metrics tools). number records written equal largest length supplied (nondefault) parameter 1 parameters supplied. lengths supplied parameters differ, shorter vectors recycled (whole number times remainder necessary). Please note function performs almost validity checks supplied fields. particular, extra careful constructing paired-end BAM alignments, necessary use `samtools` perform validity check manual editing BAM->SAM conversion.","code":""},{"path":[]},{"path":"/reference/simulateBam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"simulateBam — simulateBam","text":"","code":"out.bam <- tempfile(pattern=\"simulated\", fileext=\".bam\")   simulateBam(     output.bam.file=out.bam,     pos=c(1, 2),     XM=c(\"ZZZzzZZZ\", \"ZZzzzzZZ\"),     XG=c(\"CT\", \"AG\"),     xi=5:6,     xf=0.05,     ai=list(as.integer(c(1:3)), as.integer(c(4:6))),     af=list(seq(-1, 1, 0.5))   ) #> Writing sample BAM  #> [0.002s] #> [1] 2   generateCytosineReport(out.bam, threshold.reads=FALSE) #> Checking BAM file:  #> short-read, single-end, unsorted alignment detected #> Reading single-end BAM file  #> [0.001s] #> Preparing cytosine report  #> [0.000s] #>      rname strand   pos context  meth unmeth #>     <fctr> <fctr> <int>  <fctr> <int>  <int> #>  1:   chrS      +     1      CG     1      0 #>  2:   chrS      +     2      CG     1      0 #>  3:   chrS      -     2      CG     1      0 #>  4:   chrS      +     3      CG     1      0 #>  5:   chrS      -     3      CG     1      0 #>  6:   chrS      +     4      CG     0      1 #>  7:   chrS      -     4      CG     0      1 #>  8:   chrS      +     5      CG     0      1 #>  9:   chrS      -     5      CG     0      1 #> 10:   chrS      +     6      CG     1      0 #> 11:   chrS      -     6      CG     0      1 #> 12:   chrS      +     7      CG     1      0 #> 13:   chrS      -     7      CG     0      1 #> 14:   chrS      +     8      CG     1      0 #> 15:   chrS      -     8      CG     1      0 #> 16:   chrS      -     9      CG     1      0   # check this BAM with `samtools view` or using `output.bam.file=NULL`"}]
